--- src/App.tsx ---
// App.tsx
import React from 'react';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import Router from './navigation/Router';
import { AuthProvider } from './context/AuthContext';
import { DataProvider } from './context/DataContext';

const App = () => {
  return (
    <SafeAreaProvider>
      <DataProvider>
      <AuthProvider>
        <Router />
      </AuthProvider>
      </DataProvider>
    </SafeAreaProvider>
  );
};

export default App;
--- src/assets/icons/add.png ---




--- src/components/Calendar/CalendarComponent.tsx ---
import React from 'react';
import { Text, View } from 'react-native';
import { Calendar } from 'react-native-calendars';
import styles from './styles';
import XDate from 'xdate';
import { Colors } from '../../globalStyles';

const CalendarComponent = ({ attendanceData }: { attendanceData: Record<string, string> }) => {
  // Get today's date dynamically
  const today = new Date();
  const todayString = today.toISOString().split('T')[0]; // e.g., "2025-05-06"

  const markedDates = Object.keys(attendanceData).reduce<
    Record<string, { selected: boolean; selectedColor: string; disableTouchEvent: boolean; disabled?: boolean }>
  >((acc, date) => {
    const isFutureDate = date > todayString; // Check if the date is after today
    acc[date] = {
      selected: true,
      selectedColor: attendanceData[date] === 'Present' ? Colors.success : Colors.error,
      disableTouchEvent: true, // Disable touch for all dates (as per your existing logic)
      disabled: isFutureDate, // Visually disable future dates
    };
    return acc;
  }, {});

  return (
    <View style={styles.calendarContainer}>
      <Calendar
        markedDates={markedDates}
        style={styles.calendar}
        maxDate={todayString} // Restrict navigation to today (e.g., "2025-05-06")
        theme={{
          backgroundColor: Colors.white,
          calendarBackground: Colors.white,
          textSectionTitleColor: Colors.text,
          selectedDayBackgroundColor: Colors.accent,
          selectedDayTextColor: Colors.white,
          todayTextColor: Colors.accent,
          dayTextColor: Colors.text,
          textDisabledColor: Colors.lightGray,
          dotColor: Colors.accent,
          selectedDotColor: Colors.white,
          arrowColor: Colors.accent,
          monthTextColor: Colors.text,
          indicatorColor: Colors.accent,
          disabledArrowColor: Colors.lightGray,
        }}
        renderHeader={(date) => (
          <Text style={styles.customHeader}>
            {date ? new XDate(date).toString('MMMM yyyy') : ''}
          </Text>
        )}
      />
    </View>
  );
};

export default CalendarComponent;
--- src/components/Calendar/styles.tsx ---
import {Dimensions, StyleSheet} from 'react-native';
import { Fonts, Colors, Spacing, BorderRadius } from '../../globalStyles';

const {height, width} = Dimensions.get('window');
const styles = StyleSheet.create({
	calendar: {
		marginBottom: Spacing.l,
		borderWidth: 1,
		borderColor: Colors.lightGray,
		height: height / 2.2,
		alignSelf: 'center',
		width: width - 40,
		borderRadius: BorderRadius.lg,
		backgroundColor: Colors.white,
	},
	customHeader: {
		fontSize: 32,
		fontWeight: '600',
		color: Colors.text,
		textAlign: 'center',
		fontFamily: Fonts.PFbold,
		marginVertical: Spacing.m,
	},
	calendarContainer: {
		padding: Spacing.m,
		backgroundColor: Colors.white,
		borderRadius: BorderRadius.lg,
	},
});

export default styles;
--- src/components/CourseSelector/CourseSelector.tsx ---
import React, { useEffect } from 'react';
import { View, Text, ActivityIndicator } from 'react-native';
import { Picker } from '@react-native-picker/picker';
import { useData } from '../../context/DataContext';
import { Colors} from '../../globalStyles';
import styles from './styles';


const CourseSelector: React.FC = () => {
  const { courseData, fetchCourseData, selectedCourse, setSelectedCourse } = useData();

  // Fetch courses when the component mounts
  useEffect(() => {
    if (!courseData) {
      fetchCourseData();
    }
  }, [courseData, fetchCourseData]);

  return (
    <View style={styles.container}>
      <Text style={styles.label}>Select Course</Text>
      {courseData ? (
        <Picker
          selectedValue={selectedCourse}
          onValueChange={(itemValue) => setSelectedCourse(itemValue)}
          style={styles.picker}
          dropdownIconColor={Colors.accent}
        >
          <Picker.Item
            label="Select a course..."
            value={null}
            color={Colors.textLight}
          />
          {courseData.map((course) => (
            <Picker.Item
              key={course.$id}
              label={course.Programme}
              value={course.$id}
              color={Colors.text}
            />
          ))}
        </Picker>
      ) : (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="small" color={Colors.accent} />
          <Text style={styles.loadingText}>Loading courses...</Text>
        </View>
      )}
    </View>
  );
};

export default CourseSelector;
--- src/components/CourseSelector/styles.tsx ---
import { StyleSheet } from 'react-native';
import { Colors, Fonts, Spacing, BorderRadius, Responsive } from '../../globalStyles';

const styles = StyleSheet.create({
  container: {
    margin: Spacing.m,
    padding: Spacing.m,
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.md,
  },
  label: {
    fontSize: Responsive.fontSize.md,
    fontFamily: Fonts.PFbold,
    color: Colors.text,
    marginBottom: Spacing.s,
    fontWeight: '600',
  },
  picker: {
    height: 50,
    width: '100%',
    borderWidth: 1,
    borderColor: Colors.lightGray,
    borderRadius: BorderRadius.sm,
    backgroundColor: Colors.white,
    color: Colors.text,
  },
  loadingContainer: {
    padding: Spacing.m,
    alignItems: 'center',
  },
  loadingText: {
    color: Colors.textLight,
    fontSize: Responsive.fontSize.sm,
    fontFamily: Fonts.PFregular,
    marginTop: Spacing.s,
  },
});

export default styles;
--- src/components/navigation/CustomTabBar.tsx ---
import React from 'react';
import {View, TouchableOpacity, Image} from 'react-native';
import {BottomTabBarProps} from '@react-navigation/bottom-tabs';
import {styles} from './styles';
import { Colors } from '../../globalStyles';

const iconMap = {
  Home: {
    outline: require('../../assets/icons/home.png'),
    filled: require('../../assets/icons/home-filled.png'),
  },
  Attendance: {
    outline: require('../../assets/icons/attendance.png'),
    filled: require('../../assets/icons/attendance-filled.png'),
  },
  Students: {
    outline: require('../../assets/icons/students.png'),
    filled: require('../../assets/icons/students-filled.png'),
  },
  Courses: {
    outline: require('../../assets/icons/courses.png'),
    filled: require('../../assets/icons/courses-filled.png'),
  },
};

function CustomTabBar({state, navigation}: BottomTabBarProps): React.ReactNode {
  return (
    <View style={styles.tabContainer}>
      {state.routes.map((route, index) => {
        const isFocused = state.index === index;

        const onPress = () => {
          if (!isFocused) {
            navigation.navigate(route.name);
          }
        };

        const iconSource = isFocused
          ? iconMap[route.name as keyof typeof iconMap].filled
          : iconMap[route.name as keyof typeof iconMap].outline;

        return (
          <TouchableOpacity
            key={route.key}
            onPress={onPress}
            style={styles.tab}>
            <Image
              source={iconSource}
              style={[
                styles.icon,
                { tintColor: isFocused ? Colors.accent : Colors.secondary },
              ]}
            />
            {isFocused && <View style={styles.activeIndicator} />}
          </TouchableOpacity>
        );
      })}
    </View>
  );
}

export default CustomTabBar;
--- src/components/navigation/styles.tsx ---
import { StyleSheet } from 'react-native';
import { Colors, Spacing, BorderRadius } from '../../globalStyles';

export const styles = StyleSheet.create({
    tabContainer: {
      flexDirection: 'row',
      height: 65,
      borderTopWidth: 1,
      borderColor: Colors.lightGray,
      backgroundColor: Colors.white,
      paddingBottom: Spacing.xs,
    },
    tab: {
      flex: 1,
      alignItems: 'center',
      justifyContent: 'center',
      paddingVertical: Spacing.xs,
    },
    icon: {
      width: 24,
      height: 24,
      marginBottom: 4,
      resizeMode: 'contain',
    },
    activeIndicator: {
      position: 'absolute',
      bottom: 0,
      width: 4,
      height: 4,
      borderRadius: BorderRadius.round,
      backgroundColor: Colors.accent,
    },
  });
--- src/components/QR/AttendanceQr.tsx ---
import React, { useEffect, useState } from 'react';
import { Text, View, ActivityIndicator } from 'react-native';
import QRCode from 'react-native-qrcode-svg';
import { useData } from '../../context/DataContext';
import { useAuth } from '../../context/AuthContext';
import { Colors } from '../../globalStyles';
import styles from './styles';

interface AttendanceQRProps {
  sessionId: string;
  selectedCourse: string;
}

export default function AttendanceQR({  selectedCourse }: AttendanceQRProps) {
  const [qrData, setQrData] = useState('');
  const { latitude, longitude } = useData();
  const { user } = useAuth();
  const [isLoading, setIsLoading] = useState(true);

  const isLocationValid =
    latitude !== undefined &&
    longitude !== undefined &&
    latitude !== null &&
    longitude !== null &&
    latitude !== '' &&
    longitude !== '';

  useEffect(() => {
    const updateQR = () => {
      setIsLoading(true);
      console.log('QR latitude:', latitude, 'longitude:', longitude);
      if (!user || !selectedCourse) {
        setQrData('');
        setIsLoading(false);
        return;
      }
      if (!isLocationValid) {
        setQrData('');
        setIsLoading(false);
        return;
      }
      const now = new Date();
      const expiresAt = new Date(now.getTime() + 10 * 60 * 1000);
      const qrPayload = {
        expiresAt: expiresAt.toISOString(),
        courseId: selectedCourse,
        latitude: Number(latitude),
        longitude: Number(longitude),
      };
      const qrString = JSON.stringify(qrPayload);
      setQrData(qrString);
      setIsLoading(false);
      console.log('✅ QR code generated with payload:', qrString);
    };
    updateQR();
    const interval = setInterval(updateQR, 5000); // 5 seconds
    return () => clearInterval(interval);
  }, [user, selectedCourse, latitude, longitude]);

  return (
    <View style={styles.container}>
      <View style={styles.qrContainer}>
        {isLoading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={Colors.accent} />
            <Text style={styles.loadingText}>Generating QR Code...</Text>
          </View>
        ) : qrData ? (
          <QRCode
            value={qrData}
            size={250}
            backgroundColor={Colors.white}
            color={Colors.primary}
          />
        ) : (
          <Text style={styles.errorText}>
            Please set location in Home screen to generate QR code...
          </Text>
        )}
      </View>
      <Text style={styles.timestamp}>
        Updated: {new Date().toLocaleTimeString()}
      </Text>
    </View>
  );
}
--- src/components/QR/styles.tsx ---
import { StyleSheet } from 'react-native';
import { Colors, Fonts, Responsive, BorderRadius, Spacing } from '../../globalStyles';

const { wp, fontSize } = Responsive;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.background,
    alignItems: 'center',
    justifyContent: 'center',
    padding: Spacing.l,
  },
  qrContainer: {
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.lg,
    padding: Spacing.l,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: Spacing.l,
  },
  qr: {
    width: wp(60),
    height: wp(60),
  },
  timestamp: {
    marginTop: Spacing.m,
    fontSize: fontSize.md,
    color: Colors.textLight,
    fontFamily: Fonts.PFregular,
    textAlign: 'center',
  },
  errorText: {
    color: Colors.error,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
    marginTop: Spacing.m,
    textAlign: 'center',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: Colors.background,
  },
  loadingText: {
    fontSize: fontSize.md,
    color: Colors.textLight,
    fontFamily: Fonts.PFregular,
    marginTop: Spacing.m,
    textAlign: 'center',
  },
  permissionContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: Spacing.l,
  },
  permissionText: {
    fontSize: fontSize.md,
    color: Colors.text,
    fontFamily: Fonts.PFmedium,
    textAlign: 'center',
    marginBottom: Spacing.m,
  },
  button: {
    backgroundColor: Colors.primary,
    paddingVertical: Spacing.m,
    paddingHorizontal: Spacing.xl,
    borderRadius: BorderRadius.md,
    alignItems: 'center',
    marginTop: Spacing.m,
  },
  buttonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFbold,
  },
});

export default styles;
--- src/context/AuthContext.tsx ---
import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';
import { account, databases } from '../lib/appwrite';
import { ID, Models, Permission, Query, Role } from 'appwrite';
import { DataProvider, useData } from './DataContext';
import DeviceInfo from 'react-native-device-info';

interface AppContextType {
  user: Models.User<Models.Preferences> | null;
  authLoading: boolean;
  authError: string | null;
  login: (email: string, password: string) => Promise<Models.User<Models.Preferences>>;
  logout: () => Promise<void>;
  checkLoggedIn: () => Promise<void>;
  attendanceLogs: Models.Document[] | null; // Add attendance logs to context
}

const AppContext = createContext<AppContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<Models.User<Models.Preferences> | null>(null);
  const [authLoading, setAuthLoading] = useState(true);
  const [authError, setAuthError] = useState<string | null>(null);
  const [attendanceLogs, setAttendanceLogs] = useState<Models.Document[] | null>(null); // State for attendance logs

  const {fetchCourseData, fetchStudentsDataAll, fetchAttendanceData} = useData();

  const login = async (email: string, password: string): Promise<Models.User<Models.Preferences>> => {
    try {
      setAuthError(null);
      try {
        await account.deleteSession('current');
      } catch (error: any) {
        console.log('⚠️ No session to delete:', error.message);
      }

      await account.createEmailPasswordSession(email, password);
      const currentUser = await account.get();
      console.log('✅ Login successful:', currentUser);

      if (currentUser.prefs.role !== 'student' && currentUser.prefs.role !== 'admin') {
        await account.deleteSession('current');
        throw new Error('Access denied. You are not authorized to use this app.');
      }

      if (currentUser.prefs.role === 'student') {
        const deviceUUID = await DeviceInfo.getUniqueId();
        console.log('📱 Device UUID:', deviceUUID);
        const DB_ID = '6819e71f002774754561';
        const UUID_COLLECTION_ID = '6819e7f0000f2c60c7cd';
        const STUDENT_COLLECTION_ID = '6819e983001dc900e9f9';
        const ATTENDANCE_COLLECTION_ID = '6819e8e100130bc54117';
        const allUUID = await databases.listDocuments(DB_ID, UUID_COLLECTION_ID, [
          Query.equal('DeviceUUID', deviceUUID),
        ]);
        const matchedUUID = allUUID.documents[0];
        console.log('📦 Matched UUID Data:', matchedUUID);
        const studentDocs = await databases.listDocuments(DB_ID, STUDENT_COLLECTION_ID, []);

        const attendanceDocs = await databases.listDocuments(DB_ID, ATTENDANCE_COLLECTION_ID);
        console.log('Attendance Logs', attendanceDocs);
        setAttendanceLogs(attendanceDocs.documents);

        const studentDoc = studentDocs.documents[0];
        const studentUUID = studentDoc?.uUID;
        console.log('📦 Student Record:', studentDoc);
        console.log('🔗 Student UUID Data:', studentUUID);
        // Case 1: Device already linked to a different student
        if (matchedUUID && !studentUUID) {
          await account.deleteSession('current');
          throw new Error('This device is already linked to a different student account.');
        }
        // Case 2: UUID exists but doesn't match
        if (
          matchedUUID &&
          studentUUID &&
          matchedUUID.$id !== studentUUID.$id
        ) {
          await account.deleteSession('current');
          throw new Error('This device is linked to a different student account.');
        }
        // Case 3: UUID matches
        if (
          matchedUUID &&
          studentUUID &&
          matchedUUID.$id === studentUUID.$id
        ) {
          console.log('✅ Device UUID matches student record.');
        }
        // New Case: matchedUUID exists, but studentUUID is not set
        else if (matchedUUID && !studentUUID) {
          await databases.updateDocument(DB_ID, STUDENT_COLLECTION_ID, studentDoc.$id, {
            uUID: matchedUUID.$id,
          });
          console.log('✅ Updated student record with existing UUID.');
        }
        // Case 4: Neither UUID exists
        else if (!matchedUUID && !studentUUID) {
          const newUUIDDoc = await databases.createDocument(DB_ID, UUID_COLLECTION_ID, ID.unique(), {
            DeviceUUID: deviceUUID,
            email: currentUser.email,
          }, [
            Permission.read(Role.user(currentUser.$id)),
            Permission.update(Role.user(currentUser.$id)),
          ]);

          try {
            await databases.updateDocument(DB_ID, STUDENT_COLLECTION_ID, studentDoc.$id, {
              uUID: newUUIDDoc.$id,
            });
            console.log('✅ Device UUID assigned to new student.');
          } catch (err) {
            console.error('❌ Failed to update student with UUID:', err);
            throw err;
          }
        }
        // Case 5: Account linked to a different device
        else if (!matchedUUID && studentUUID) {
          await account.deleteSession('current');
          throw new Error('This account is already linked to a different device.');
        }
      }

      if(currentUser.prefs.role === 'admin'){
        await fetchCourseData();
        await fetchStudentsDataAll();
        await fetchAttendanceData();
        console.log('Admin has logged in');
      }

      setUser(currentUser);
      return currentUser;
    } catch (err: any) {
      console.error('❌ Login failed:', err.message);
      setAuthError(err.message);
      throw err;
    }
  };


  const logout = async () => {
    try {
      console.log('🚪 Logging out...');
      await account.deleteSession('current');
      setUser(null);
      setAttendanceLogs(null); // Clear attendance logs on logout
      console.log('✅ Logout successful');
    } catch (err: any) {
      console.error('❌ Logout failed:', err.message);
    }
  };

  const checkLoggedIn = useCallback(async () => {
    try {
      console.log('🕵️‍♂️ Checking user session...');
      const currentUser = await account.get();
      console.log('✅ User is logged in:', currentUser.email);
      setUser(currentUser);
    } catch (err: any) {
      console.warn('⚠️ No active session:', err.message);
      setUser(null);
    } finally {
      setAuthLoading(false);
    }
  }, []);

  useEffect(() => {
    checkLoggedIn();
  }, [checkLoggedIn]);

  return (
    <AppContext.Provider value={{ user, authLoading, login, logout, authError,checkLoggedIn, attendanceLogs}}>
    {user ? (
      <DataProvider>
        {children}
      </DataProvider>
    ) : (
      children
    )}
    </AppContext.Provider>
  );
};

export const useAuth = (): AppContextType => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
--- src/context/DataContext.tsx ---
import React, { createContext, useContext, useState, ReactNode, useEffect } from 'react';
import { account, databases, functions } from '../lib/appwrite';
import { ID, Models, Permission, Role, Query, AppwriteException } from 'appwrite';
import Geolocation from '@react-native-community/geolocation';
import {
  check,
  request,
  PERMISSIONS,
  RESULTS,
} from 'react-native-permissions';
import { Platform, Alert } from 'react-native';

interface DataContextType {
  studentData: Models.Document | null;
  setStudentData: React.Dispatch<React.SetStateAction<Models.Document | null>>;
  fetchStudentData: () => Promise<void>;

  courseData: Models.Document[] | null;
  setCourseData: React.Dispatch<React.SetStateAction<Models.Document[] | null>>;
  fetchCourseData: () => Promise<void>;

  addCourse: (name: string, duration: number, status: 'Active' | 'Inactive') => Promise<void>;
  updateCourse: (id: string, name: string, duration: number, status: 'Active' | 'Inactive') => Promise<void>;
  deleteCourse: (id: string) => Promise<void>;

  studentsDataAll: Models.Document[] | null;
  setStudentsDataAll: React.Dispatch<React.SetStateAction<Models.Document[] | null>>;
  fetchStudentsDataAll: () => Promise<void>;
  getBackendMarkedAttendanceByDate: (date: string) => Promise<Models.Document[]>;

  addStudent: (
    name: string,
    email: string,
    gender: 'Male' | 'Female' | 'Others',
    abc_id: number,
    semester: number,
    batch: number,
    year: 'First' | 'Second' | 'Third' | 'Fourth' | 'Fifth',
    status: 'Active' | 'Inactive',
    courseId: string
  ) => Promise<void>;

  bulkAddStudents: (fileContent: string, fileType: 'csv' | 'json') => Promise<void>;

  updateStudent: (
    id: string,
    name: string,
    email: string,
    gender: 'Male' | 'Female' | 'Others',
    abc_id: number,
    semester: number,
    batch: number,
    year: 'First' | 'Second' | 'Third' | 'Fourth' | 'Fifth',
    status: 'Active' | 'Inactive',
    courseId: string
  ) => Promise<void>;

  deleteStudent: (id: string) => Promise<void>;

  attendanceData: Models.Document[] | null;
  setAttendanceData: React.Dispatch<React.SetStateAction<Models.Document[] | null>>;
  fetchAttendanceData: () => Promise<void>;

  markPresent: (studentId: string, date: string) => void;
  unmarkPresent: (studentId: string, date: string) => void;
  getMarkedStudents: (date: string) => string[];
  saveAttendance: (date: string, courseId: string, sessionId: string, latitude: number | null, longitude: number | null) => Promise<void>;
  markPresentByQR: (studentId: string, date: string) => void;
  resetManualAttendance: (date: string) => void;

  selectedCourse: string | null;
  setSelectedCourse: React.Dispatch<React.SetStateAction<string | null>>;

  latitude: string;
  longitude: string;
  locationId: string | null;
  hasExistingLocation: boolean;
  isLocationLoading: boolean;
  setLatitude: React.Dispatch<React.SetStateAction<string>>;
  setLongitude: React.Dispatch<React.SetStateAction<string>>;
  fetchLocation: () => Promise<void>;
  saveLocation: () => Promise<void>;
  handleUpdateLocation: () => Promise<void>;
}

const DataContext = createContext<DataContextType | undefined>(undefined);
const DB_ID = '6819e71f002774754561';
const STUDENT_COLLECTION_ID = '6819e983001dc900e9f9';
const COURSE_COLLECTION_ID = '6819e836002f8c03c689';
const ATTENDANCE_COLLECTION_ID = '6819e8e100130bc54117';
const CREATE_USER_FUNCTION_ID = '683aac1c003b413d2502';
const DELETE_USER_FUNCTION_ID = '683b6aee0021ec3b47d2';
const GET_USER_ID_FUNCTION_ID = '683b696c001e971bfc8f';
const LOCATION_COLLECTION_ID = '6839818e00303c1ed20e';

export const DataProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [studentData, setStudentData] = useState<Models.Document | null>(null);
  const [courseData, setCourseData] = useState<Models.Document[] | null>(null);
  const [studentsDataAll, setStudentsDataAll] = useState<Models.Document[] | null>(null);
  const [attendanceData, setAttendanceData] = useState<Models.Document[] | null>(null);
  const [manualAttendance, setManualAttendance] = useState<{ [date: string]: string[] }>({});
  const [selectedCourse, setSelectedCourse] = useState<string | null>(null);
  const [latitude, setLatitude] = useState<string>('');
  const [longitude, setLongitude] = useState<string>('');
  const [locationId, setLocationId] = useState<string | null>(null);
  const [hasExistingLocation, setHasExistingLocation] = useState(false);
  const [isLocationLoading, setIsLocationLoading] = useState(false);

  const getUserIdByEmail = async (email: string): Promise<string | null> => {
    try {
      const execution = await functions.createExecution(
        GET_USER_ID_FUNCTION_ID,
        JSON.stringify({ email }),
        false
      );

      if (!execution.responseBody) {
        throw new Error('Function returned an empty response');
      }

      const response = JSON.parse(execution.responseBody);
      if (!response.success) {
        console.warn('⚠️ User not found for email:', email);
        return null;
      }

      return response.userId;
    } catch (err) {
      console.error('❌ Failed to fetch userId by email:', err);
      return null;
    }
  };

  const deleteUserByEmail = async (email: string): Promise<void> => {
    try {
        if (!email || typeof email !== 'string') {
            console.warn('⚠️ Invalid email provided for deletion:', email);
            return;
        }
        console.log('Sending delete request for email:', email);
        const payload = JSON.stringify({ email });
        console.log('Payload sent to deleteUserByEmail:', payload);
        console.log('Function ID:', DELETE_USER_FUNCTION_ID);
        const execution = await functions.createExecution(
            DELETE_USER_FUNCTION_ID,
            payload,
            false
        );

        console.log('Execution response:', execution);
        if (!execution.responseBody) {
            console.error('❌ Empty response from deleteUserByEmail function');
            console.log('Execution details:', JSON.stringify(execution, null, 2));
            throw new Error('Function returned an empty response');
        }

        const response = JSON.parse(execution.responseBody);
        console.log('Delete function response:', response);
        if (!response.success) {
            console.warn('⚠️ Failed to delete user:', response.error);
        } else {
            console.log('✅ User deleted via function:', email);
        }
    } catch (err) {
        console.error('❌ Failed to delete user by email:', err);
    }
};
  const fetchStudentData = async () => {
    try {
      const currentUser = await account.get();
      const response = await databases.listDocuments(
        DB_ID,
        STUDENT_COLLECTION_ID,
      );

      if (response.total > 0) {
        console.log('✅ Student Data:', response.documents[0]);
        setStudentData(response.documents[0]);
      } else {
        console.warn('⚠️ No student found for:', currentUser.$id);
        setStudentData(null);
      }
    } catch (err) {
      console.error('❌ Failed to fetch student data:', err);
      setStudentData(null);
    }
  };

  const fetchCourseData = async () => {
    try {
      const response = await databases.listDocuments(
        DB_ID,
        COURSE_COLLECTION_ID,
      );
      console.log('Course Response', response);
      setCourseData(response.documents);
    } catch (err) {
      console.error('❌ Failed to fetch course data:', err);
      setCourseData(null);
    }
  };

  const addCourse = async (name: string, duration: number, status: 'Active' | 'Inactive') => {
    try {
      await databases.createDocument(
        DB_ID,
        COURSE_COLLECTION_ID,
        ID.unique(),
        {
          Programme: name,
          Duration: duration,
          Status: status,
        }
      );
      await fetchCourseData();
    } catch (err) {
      console.error('❌ Failed to add course:', err);
    }
  };

  const updateCourse = async (id: string, name: string, duration: number, status: 'Active' | 'Inactive') => {
    try {
      await databases.updateDocument(
        DB_ID,
        COURSE_COLLECTION_ID,
        id,
        {
          Programme: name,
          Duration: duration,
          Status: status,
        }
      );
      await fetchCourseData();
    } catch (err) {
      console.error('❌ Failed to update course:', err);
    }
  };

  const deleteCourse = async (id: string) => {
    try {
      await databases.deleteDocument(
        DB_ID,
        COURSE_COLLECTION_ID,
        id
      );
      await fetchCourseData();
    } catch (err) {
      console.error('❌ Failed to delete course:', err);
    }
  };

  const fetchStudentsDataAll = async () => {
    try {
      const response = await databases.listDocuments(
        DB_ID,
        STUDENT_COLLECTION_ID,
      );
      console.log('Student Response', response);
      setStudentsDataAll(response.documents);
    } catch (err) {
      console.error('❌ Failed to fetch Students data:', err);
      setStudentsDataAll(null);
    }
  };

  const checkStudentExists = async (email: string, abc_id: number): Promise<boolean> => {
    try {
      const [emailCheck, abcIdCheck] = await Promise.all([
        databases.listDocuments(DB_ID, STUDENT_COLLECTION_ID, [Query.equal('Email', email)]),
        databases.listDocuments(DB_ID, STUDENT_COLLECTION_ID, [Query.equal('ABC_ID', abc_id)]),
      ]);
      return emailCheck.total > 0 || abcIdCheck.total > 0;
    } catch (err) {
      console.error('❌ Failed to check student existence:', err);
      return false;
    }
  };

  const createUserForStudent = async (name: string, email: string): Promise<string> => {
    const defaultPassword = 'student123';
    const userId = ID.unique();
    try {
      const payload = {
        email,
        name,
        password: defaultPassword,
        userId,
      };
      console.log('Sending payload to function:', payload);

      const execution = await functions.createExecution(
        CREATE_USER_FUNCTION_ID,
        JSON.stringify(payload),
        false
      );

      console.log('Function execution response:', execution);

      if (!execution.responseBody) {
        throw new Error('Function returned an empty response');
      }

      let response;
      try {
        response = JSON.parse(execution.responseBody);
      } catch (parseError) {
        console.error('Failed to parse function response:', execution.responseBody);
        throw new Error('Invalid response from function: ' + (parseError instanceof Error ? parseError.message : 'Unknown parse error'));
      }

      if (!response.success) {
        throw new Error(response.error || 'Failed to create user via function');
      }

      console.log('✅ User created via function:', response.user);
      return response.user.userId;
    } catch (err) {
      const errorMessage = err instanceof AppwriteException ? err.message : err.message || 'Unknown error';
      console.error('❌ Failed to create user for student:', err);
      throw new Error('Failed to create user: ' + errorMessage);
    }
  };

  const addStudent = async (
    name: string,
    email: string,
    gender: 'Male' | 'Female' | 'Others',
    abc_id: number,
    semester: number,
    batch: number,
    year: 'First' | 'Second' | 'Third' | 'Fourth' | 'Fifth',
    status: 'Active' | 'Inactive',
    courseId: string
  ) => {
    try {
      // Check if a student with the same email, ABC ID, and course ID exists
      const studentExists = await checkStudentExists(email, abc_id);
      if (studentExists) {
        console.warn(`⚠️ Skipping student with email: ${email}, ABC ID: ${abc_id}, Course ID: ${courseId} - already exists.`);
        throw new Error('A student with this email, ABC ID, and course already exists.');
      }

      // Add student to the student collection first
      const studentDoc = await databases.createDocument(
        DB_ID,
        STUDENT_COLLECTION_ID,
        ID.unique(),
        {
          Name: name,
          Email: email,
          Gender: gender,
          ABC_ID: abc_id,
          Semester: semester,
          Batch: batch,
          Year: year,
          Status: status,
          Course: courseId,
          Address: null,
          uUID: null,
        },
        [
          Permission.read(Role.any()),
          Permission.update(Role.any()),
          Permission.delete(Role.any()),
        ]
      );

      console.log('✅ Student added to collection:', studentDoc);

      // Attempt to create user in Appwrite Users service
      try {
        const userId = await createUserForStudent(name, email);
        // Update the student document with the userId if needed
        await databases.updateDocument(
          DB_ID,
          STUDENT_COLLECTION_ID,
          studentDoc.$id,
          {
            userId: userId, // Optionally store the userId in the student document
          }
        );
        console.log('✅ User created and linked to student:', userId);
      } catch (userErr) {
        console.warn('⚠️ User creation failed, but student data is stored:', userErr);
        // No need to throw here; student data is already saved
      }

      await fetchStudentsDataAll();
    } catch (err) {
      console.error('❌ Failed to add student:', err);
      throw err;
    }
  };

  const bulkAddStudents = async (fileContent: string, fileType: 'csv' | 'json') => {
    try {
      let students: any[] = [];
      let skippedStudents: string[] = [];
      let addedStudents: string[] = [];

      if (fileType === 'csv') {
        const rows = fileContent.trim().split('\n');
        const headers = rows[0].split(',').map((header: string) => header.trim());
        students = rows.slice(1).map((row: string) => {
          const values = row.split(',').map((value: string) => value.trim());
          return headers.reduce((obj: any, header: string, index: number) => {
            obj[header] = values[index];
            return obj;
          }, {});
        });
      } else if (fileType === 'json') {
        students = JSON.parse(fileContent);
        if (!Array.isArray(students)) {
          throw new Error('JSON file must contain an array of students.');
        }
      }

      for (const student of students) {
        const {
          Name: name,
          Email: email,
          Gender: gender,
          ABC_ID: abc_id,
          Semester: semester,
          Batch: batch,
          Year: year,
          Status: status,
          Course: courseId,
        } = student;

        if (!name || !email || !gender || !abc_id || !semester || !batch || !year || !status || !courseId) {
          console.warn('⚠️ Skipping invalid student entry:', student);
          skippedStudents.push(name || email || 'Unknown');
          continue;
        }

        const validGenders = ['Male', 'Female', 'Others'];
        const validYears = ['First', 'Second', 'Third', 'Fourth', 'Fifth'];
        const validStatuses = ['Active', 'Inactive'];

        if (!validGenders.includes(gender) || !validYears.includes(year) || !validStatuses.includes(status)) {
          console.warn('⚠️ Skipping student with invalid values:', student);
          skippedStudents.push(name || email || 'Unknown');
          continue;
        }

        const studentExists = await checkStudentExists(email, parseInt(abc_id));
        if (studentExists) {
          console.warn(`⚠️ Skipping student with email: ${email}, ABC ID: ${abc_id}, Course ID: ${courseId} - already exists.`);
          skippedStudents.push(name || email);
          continue;
        }

        try {
          await addStudent(
            name,
            email,
            gender,
            parseInt(abc_id),
            parseInt(semester),
            parseInt(batch),
            year,
            status,
            courseId
          );
          addedStudents.push(name || email);
        } catch (err) {
          console.warn(`⚠️ Failed to add student ${name || email}, but data may be stored:`, err);
          // Note: If addStudent partially succeeded (student added to collection but user creation failed), it's already handled
          skippedStudents.push(name || email);
        }
      }

      await fetchStudentsDataAll();
      console.log('✅ Bulk student import completed');
      console.log('✅ Added students:', addedStudents);
      console.log('⚠️ Skipped students:', skippedStudents);

      // Provide feedback to the user
      if (skippedStudents.length > 0) {
        throw new Error(
          `Imported ${addedStudents.length} students. Skipped ${skippedStudents.length} students due to duplicates or errors: ${skippedStudents.join(', ')}`
        );
      }
    } catch (err) {
      console.error('❌ Failed to bulk import students:', err);
      throw err;
    }
  };

  const updateStudent = async (
    id: string,
    name: string,
    email: string,
    gender: 'Male' | 'Female' | 'Others',
    abc_id: number,
    semester: number,
    batch: number,
    year: 'First' | 'Second' | 'Third' | 'Fourth' | 'Fifth',
    status: 'Active' | 'Inactive',
    courseId: string,
  ) => {
    try {
      const currentStudent = await databases.getDocument(DB_ID, STUDENT_COLLECTION_ID, id);
      const studentExists = await checkStudentExists(email, abc_id);
      if (studentExists && (currentStudent.Email !== email || currentStudent.ABC_ID !== abc_id || currentStudent.Course.$id !== courseId)) {
        throw new Error('A student with this email, ABC ID, and course already exists.');
      }

      const newUserId = await getUserIdByEmail(email);
      const permissions = newUserId
        ? [
            Permission.read(Role.user(newUserId)),
            Permission.update(Role.user(newUserId)),
            Permission.delete(Role.user(newUserId)),
            Permission.read(Role.label('admin')),
            Permission.update(Role.label('admin')),
            Permission.delete(Role.label('admin')),
          ]
        : [
            Permission.read(Role.label('admin')),
            Permission.update(Role.label('admin')),
            Permission.delete(Role.label('admin')),
          ];
      await databases.updateDocument(
        DB_ID,
        STUDENT_COLLECTION_ID,
        id,
        {
          Name: name,
          Email: email,
          Gender: gender,
          ABC_ID: abc_id,
          Semester: semester,
          Batch: batch,
          Year: year,
          Status: status,
          Course: courseId,
          Address: null,
          uUID: null,
        },permissions
      );

      await fetchStudentsDataAll();
      console.log('🚀 updateStudent payload:', {
        Name: name,
        Email: email,
        Gender: gender,
        ABC_ID: abc_id,
        Semester: semester,
        Batch: batch,
        Year: year,
        Status: status,
      });
    } catch (err) {
      console.error('❌ Failed to update Student:', err);
      throw err;
    }
  };

const deleteStudent = async (id: string) => {
    try {
      // Retrieve the student document to get the Email
      const studentDoc = await databases.getDocument(DB_ID, STUDENT_COLLECTION_ID, id);
      const email = studentDoc.Email;

      // Delete the user from authentication service if email exists
      if (email) {
        await deleteUserByEmail(email);
      } else {
        console.warn('⚠️ No email found for student document:', id);
      }

      // Delete the student document
      await databases.deleteDocument(DB_ID, STUDENT_COLLECTION_ID, id);
      console.log('✅ Student document deleted:', id);

      await fetchStudentsDataAll();
    } catch (err) {
      console.error('❌ Failed to delete student:', err);
      throw err;
    }
  };

  const fetchAttendanceData = async () => {
    try {
      const response = await databases.listDocuments(
        DB_ID,
        ATTENDANCE_COLLECTION_ID,
      );
      console.log('Attendance Response', response);
      setAttendanceData(response.documents);
    } catch (err) {
      console.error('❌ Failed to fetch Attendance record:', err);
    }
  };

  const markPresent = (studentId: string, date: string) => {
    setManualAttendance(prev => ({
      ...prev,
      [date]: Array.from(new Set([...(prev[date] || []), studentId])),
    }));
  };

  const unmarkPresent = async (studentId: string, date: string) => {
    setManualAttendance(prev => ({
      ...prev,
      [date]: (prev[date] || []).filter(id => id !== studentId),
    }));

    try {
      const response = await databases.listDocuments(DB_ID, ATTENDANCE_COLLECTION_ID);
      const target = response.documents.find(
        doc => {
          const docStudentId = typeof doc.Student_Id === 'object' ? doc.Student_Id.$id : doc.Student_Id;
          return docStudentId === studentId && doc.Marked_at?.slice(0, 10) === date;
        }
      );
      if (target) {
        await databases.deleteDocument(DB_ID, ATTENDANCE_COLLECTION_ID, target.$id);
        await fetchAttendanceData();
      }
    } catch (err) {
      console.error('❌ Failed to delete attendance record:', err);
    }
  };

  const getMarkedStudents = (date: string) => {
    return manualAttendance[date] || [];
  };

  const getBackendMarkedAttendanceByDate = async (date: string) => {
    const formattedDate = date;
    try {
      const response = await databases.listDocuments(DB_ID, ATTENDANCE_COLLECTION_ID);
      return response.documents.filter(
        (doc) => doc.Marked_at?.slice(0, 10) === formattedDate
      );
    } catch (err) {
      console.error('❌ Failed to get backend marked attendance:', err);
      return [];
    }
  };

  const resetManualAttendance = async (date: string) => {
    try {
      const backendMarked = await getBackendMarkedAttendanceByDate(date);
      if (!backendMarked.length) {
        setManualAttendance(prev => ({
          ...prev,
          [date]: [],
        }));
        return;
      }
      for (const doc of backendMarked) {
        await databases.deleteDocument(DB_ID, ATTENDANCE_COLLECTION_ID, doc.$id);
      }
      setManualAttendance(prev => ({
        ...prev,
        [date]: [],
      }));
      await fetchAttendanceData();
    } catch (err) {
      console.error('❌ Error during resetManualAttendance:', err);
    }
  };

  const saveAttendance = async (date: string, courseId: string, sessionId: string, latitude: number | null, longitude: number | null) => {
    const currentUser = await account.get();
    const students = manualAttendance[date] || [];
    try {
      const existingRecords = await getBackendMarkedAttendanceByDate(date);
      const existingStudentIds = new Set(
        existingRecords.map(doc => doc.Student_Id?.$id || doc.Student_Id)
      );
      for (let studentId of students) {
        if (!existingStudentIds.has(studentId)) {
          await databases.createDocument(
            DB_ID,
            ATTENDANCE_COLLECTION_ID,
            ID.unique(),
            {
              Marked_at: date,
              Status: 'Present',
              Student_Id: studentId,
              Session_Id: sessionId,
              Marked_By: currentUser.name,
              Course_Id: courseId,
              Latitude: latitude,
              Longitude: longitude,
            }
          );
        }
      }
      await fetchAttendanceData();
    } catch (err) {
      console.error('❌ Failed to save attendance:', err);
      throw err;
    }
  };

  const markPresentByQR = (studentId: string, date: string) => {
    markPresent(studentId, date);
  };

  // Fetch location from DB
  const fetchLocation = async () => {
    try {
      const response = await databases.listDocuments(
        DB_ID,
        LOCATION_COLLECTION_ID,
      );
      if (response.documents && response.documents.length > 0) {
        const location = response.documents[0];
        setLatitude(location.Latitude?.toString() ?? '');
        setLongitude(location.Longitude?.toString() ?? '');
        setLocationId(location.$id);
        setHasExistingLocation(true);
      } else {
        setHasExistingLocation(false);
        setLatitude('');
        setLongitude('');
        setLocationId(null);
      }
    } catch (error) {
      setHasExistingLocation(false);
      setLatitude('');
      setLongitude('');
      setLocationId(null);
    }
  };

  // Save or update location in DB
  const saveLocation = async () => {
    if (!latitude || !longitude) {
      Alert.alert('Error', 'Please enter or fetch location coordinates.');
      return;
    }
    setIsLocationLoading(true);
    try {
      const locationData = {
        Latitude: latitude,
        Longitude: longitude,
        updated_at: new Date().toISOString(),
      };
      if (locationId) {
        await databases.updateDocument(
          DB_ID,
          LOCATION_COLLECTION_ID,
          locationId,
          locationData,
        );
      } else {
        const response = await databases.createDocument(
          DB_ID,
          LOCATION_COLLECTION_ID,
          ID.unique(),
          locationData,
        );
        setLocationId(response.$id);
      }
      setHasExistingLocation(true);
      Alert.alert('Success', 'Location saved successfully!');
    } catch (error) {
      Alert.alert('Error', 'Failed to save location.');
    } finally {
      setIsLocationLoading(false);
    }
  };

  // Get device location
  const getCurrentLocation = () => {
    return new Promise<{ latitude: number; longitude: number }>((resolve, reject) => {
      Geolocation.getCurrentPosition(
        position => {
          resolve({
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
          });
        },
        error => {
          reject(error);
        },
        { enableHighAccuracy: true, timeout: 15000, maximumAge: 10000 },
      );
    });
  };

  // Request permission and update location from device
  const handleUpdateLocation = async () => {
    const permission = Platform.select({
      android: PERMISSIONS.ANDROID.ACCESS_FINE_LOCATION,
      ios: PERMISSIONS.IOS.LOCATION_WHEN_IN_USE,
    });
    const result = await check(permission as Permission);
    if (result !== RESULTS.GRANTED) {
      const requestResult = await request(permission as Permission);
      if (requestResult !== RESULTS.GRANTED) {
        Alert.alert(
          'Location Permission Required',
          'Please grant location permission to update location.',
        );
        return;
      }
    }
    setIsLocationLoading(true);
    try {
      const location = await getCurrentLocation();
      setLatitude(location.latitude.toString());
      setLongitude(location.longitude.toString());
    } catch (error) {
      Alert.alert('Error', 'Failed to get current location.');
    } finally {
      setIsLocationLoading(false);
    }
  };

  useEffect(() => {
    fetchLocation();
  }, []);

  return (
    <DataContext.Provider value={{
      studentData,
      setStudentData,
      fetchStudentData,

      courseData,
      setCourseData,
      fetchCourseData,
      addCourse,
      updateCourse,
      deleteCourse,

      studentsDataAll,
      setStudentsDataAll,
      fetchStudentsDataAll,
      addStudent,
      bulkAddStudents,
      updateStudent,
      deleteStudent,

      attendanceData,
      setAttendanceData,
      fetchAttendanceData,

      markPresent,
      unmarkPresent,
      getMarkedStudents,
      saveAttendance,
      markPresentByQR,
      resetManualAttendance,
      getBackendMarkedAttendanceByDate,

      selectedCourse,
      setSelectedCourse,

      latitude,
      longitude,
      locationId,
      hasExistingLocation,
      isLocationLoading,
      setLatitude,
      setLongitude,
      fetchLocation,
      saveLocation,
      handleUpdateLocation,
    }}>
      {children}
    </DataContext.Provider>
  );
};

export const useData = (): DataContextType => {
  const context = useContext(DataContext);
  if (!context) {
    throw new Error('useData must be used within an DataProvider');
  }
  return context;
};
--- src/globalStyles.tsx ---
import {StyleSheet, Dimensions, PixelRatio} from 'react-native';

const {width, height} = Dimensions.get('window');

// Responsive scaling utilities
const wp = (percentage: number) => {
  const elemWidth =
    typeof percentage === 'number' ? percentage : parseFloat(percentage);
  return PixelRatio.roundToNearestPixel((width * elemWidth) / 100);
};

const hp = (percentage: number) => {
  const elemHeight =
    typeof percentage === 'number' ? percentage : parseFloat(percentage);
  return PixelRatio.roundToNearestPixel((height * elemHeight) / 100);
};

// Responsive font size
const fontSize = {
  xs: wp(3),
  sm: wp(3.5),
  md: wp(4),
  lg: wp(4.5),
  xl: wp(5),
  xxl: wp(6),
  xxxl: wp(7),
};

// Theme colors
export const Colors = {
  primary: '#000000',
  secondary: '#3E3636',
  accent: '#D72323',
  lightGray: '#F5EDED',
  gray:'gray',
  white: '#FFFFFF',
  background: '#FFFFFF',
  card: '#F5EDED',
  text: '#000000',
  textLight: '#3E3636',
  error: '#D72323',
  errorLight: '#D72453',
  success: '#34C759',
  warning: '#FF9500',
  border: '#E0E0E0',
  black: '#000000',
  gradient: {
    primary: ['#000000', '#3E3636'],
    secondary: ['#3E3636', '#D72323'],
    accent: ['#D72323', '#F5EDED'],
  },
};

// export const Colors = {
//   primary: '#2563EB',
//   secondary: '#64748B',
//   accent: '#3B82F6',
//   lightGray: '#F1F5F9',
//   white: '#FFFFFF',
//   background: '#F8FAFC',
//   card: '#FFFFFF',
//   text: '#1E293B',
//   textLight: '#64748B',
//   error: '#EF4444',
//   errorLight: '#FEE2E2',
//   success: '#22C55E',
//   warning: '#F59E0B',
//   disabled: '#94A3B8',
//   border: '#E2E8F0',
//   black: '#000000',
//   gradient: {
//     start: '#2563EB',
//     end: '#3B82F6',
//   },
// };

// Typography
export const Fonts = {
  // PFregular: 'Playfair_144pt-Regular',
  // PFblack: 'Playfair_144pt-Black',
  // PFbold: 'Playfair_144pt-Bold',
  // PFmedium: 'Playfair_144pt-PFmedium',
  PFregular: 'Arial',
  PFblack: 'Sans-serif',
  PFbold: 'Roboto',
  PFmedium: 'Roboto',
};

// Responsive spacing
export const Spacing = {
  xs: wp(1),
  s: wp(2),
  m: wp(4),
  l: wp(6),
  xl: wp(8),
  xxl: wp(10),
};

// Responsive border radius
export const BorderRadius = {
  xs: wp(1),
  sm: wp(2),
  md: wp(3),
  lg: wp(4),
  xl: wp(6),
  round: 9999,
};

// Common styles
export const CommonStyles = StyleSheet.create({
  // Layout
  container: {
    flex: 1,
    backgroundColor: Colors.background,
    paddingHorizontal: Spacing.m,
  },
  row: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  center: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  spaceBetween: {
    justifyContent: 'space-between',
  },

  // Cards
  card: {
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.md,
    padding: Spacing.m,
    marginVertical: Spacing.s,
    width: '100%',
    shadowColor: Colors.black,
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
    elevation: 5,
  },

  // Buttons
  button: {
    height: hp(6),
    borderRadius: BorderRadius.sm,
    justifyContent: 'center',
    alignItems: 'center',
    flexDirection: 'row',
    paddingHorizontal: Spacing.l,
    minWidth: wp(30),
    shadowColor: Colors.black,
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  buttonPrimary: {
    backgroundColor: Colors.primary,
  },
  buttonSecondary: {
    backgroundColor: Colors.secondary,
  },
  buttonAccent: {
    backgroundColor: Colors.accent,
  },
  buttonOutline: {
    backgroundColor: 'transparent',
    borderWidth: 1,
    borderColor: Colors.primary,
  },
  buttonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
    fontWeight: '600',
  },
  buttonOutlineText: {
    color: Colors.primary,
  },
  buttonIcon: {
    marginRight: Spacing.s,
  },

  // Inputs
  inputContainer: {
    marginBottom: Spacing.m,
    width: '100%',
  },
  input: {
    height: hp(6),
    borderWidth: 1,
    borderColor: Colors.border,
    borderRadius: BorderRadius.sm,
    paddingHorizontal: Spacing.m,
    backgroundColor: Colors.white,
    color: Colors.text,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFregular,
    shadowColor: Colors.black,
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  inputFocused: {
    borderColor: Colors.accent,
    borderWidth: 2,
  },
  inputLabel: {
    marginBottom: Spacing.xs,
    color: Colors.text,
    fontSize: fontSize.sm,
    fontFamily: Fonts.PFmedium,
    fontWeight: '500',
  },

  // Headers
  header: {
    padding: Spacing.m,
    backgroundColor: Colors.white,
    width: '100%',
    shadowColor: Colors.black,
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
    elevation: 5,
  },
  headerTitle: {
    fontSize: fontSize.lg,
    fontFamily: Fonts.PFbold,
    color: Colors.text,
    fontWeight: '700',
  },

  // Lists
  listItem: {
    padding: Spacing.m,
    borderBottomWidth: 1,
    borderBottomColor: Colors.lightGray,
    width: '100%',
    backgroundColor: Colors.white,
  },

  // Modals
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.lg,
    padding: Spacing.l,
    width: wp(90),
    maxHeight: hp(80),
    shadowColor: Colors.black,
    shadowOffset: {
      width: 0,
      height: 4,
    },
    shadowOpacity: 0.3,
    shadowRadius: 4.65,
    elevation: 8,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: Spacing.m,
    width: '100%',
    borderBottomWidth: 1,
    borderBottomColor: Colors.lightGray,
    paddingBottom: Spacing.s,
  },
  modalTitle: {
    fontSize: fontSize.lg,
    fontFamily: Fonts.PFbold,
    color: Colors.text,
    fontWeight: '700',
  },

  // Loading and error states
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: Colors.background,
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: Spacing.xl,
    backgroundColor: Colors.background,
  },
  errorMessage: {
    textAlign: 'center',
    color: Colors.error,
    marginBottom: Spacing.m,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFregular,
  },
  retryButton: {
    backgroundColor: Colors.accent,
    paddingHorizontal: Spacing.l,
    paddingVertical: Spacing.m,
    borderRadius: BorderRadius.sm,
    minWidth: wp(30),
    shadowColor: Colors.black,
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  retryButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
    fontWeight: '600',
  },

  // Search
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.sm,
    borderWidth: 1,
    borderColor: Colors.border,
    paddingHorizontal: Spacing.m,
    marginVertical: Spacing.m,
    width: '100%',
    height: hp(6),
    shadowColor: Colors.black,
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
});

// Export responsive utilities
export const Responsive = {
  wp,
  hp,
  fontSize,
  width,
  height,
  isSmallDevice: width < 375,
  isPFmediumDevice: width >= 375 && width < 414,
  isLargeDevice: width >= 414,
};
--- src/lib/appwrite.ts ---
import { Client, Account, Databases, Query, Functions } from 'appwrite'; // Added Functions, removed Users

const client = new Client()
    .setEndpoint('https://cloud.appwrite.io/v1')
    .setProject('6819e682002b26904ff9');

const account = new Account(client);
const databases = new Databases(client);
const functions = new Functions(client);

export { client, account, databases, Query, functions };
--- src/navigation/AdminStack.tsx ---
import React from 'react';
import {createBottomTabNavigator} from '@react-navigation/bottom-tabs';
import Home from '../screens/admin/Home/Home';
import Attendance from '../screens/admin/Attendance/Attendance';
import Students from '../screens/admin/Students/Students';
import Courses from '../screens/admin/Courses/Courses';
import CustomTabBar from '../components/navigation/CustomTabBar';

const Tab = createBottomTabNavigator();

const AdminStack = () => (
  <Tab.Navigator screenOptions={{headerShown: false}} tabBar={CustomTabBar}>
    <Tab.Screen name="Home" component={Home} />
    <Tab.Screen
      name="Attendance"
      component={Attendance}
      options={{tabBarLabel: () => null}}
    />
    <Tab.Screen
      name="Students"
      component={Students}
      options={{tabBarLabel: () => null}}
    />
    <Tab.Screen
      name="Courses"
      component={Courses}
      options={{tabBarLabel: () => null}}
    />
  </Tab.Navigator>
);

export default AdminStack;
--- src/navigation/AuthStack.tsx ---
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import LoginScreen from '../screens/Login/LoginScreen';
import UpdatePasswordScreen from '../screens/Password/UpdatePassword';

const Stack = createNativeStackNavigator();

const AuthStack = () => (
  <Stack.Navigator screenOptions={{ headerShown: false }}>
    <Stack.Screen
      name="LoginScreen"
      component={LoginScreen}
      options={{ animation: 'slide_from_bottom' }}
    />
    <Stack.Screen
      name="UpdatePassword"
      component={UpdatePasswordScreen}
      options={{ animation: 'slide_from_bottom' }}
    />
  </Stack.Navigator>
);

export default AuthStack;
--- src/navigation/Router.tsx ---
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { useAuth } from '../context/AuthContext';
import AuthStack from './AuthStack';
import SplashScreen from '../screens/Splash/SplashScreen';
import UpdatePasswordScreen from '../screens/Password/UpdatePassword';
import StudentStack from './StudentStack';
import AdminStack from './AdminStack';

const Router = () => {
  const { user, authLoading } = useAuth();

  if (authLoading) {
    return <SplashScreen />;
  }

  return (
    <NavigationContainer>
      {!user ? (
        <AuthStack />
      ) : user.prefs?.passwordUpdated === 'false' ? (
        <UpdatePasswordScreen />
      ) : user.prefs?.role === 'admin' ? (
        <AdminStack />
      ) : user.prefs?.role === 'student' ? (
        <StudentStack />
      ) : null}
    </NavigationContainer>
  );
};

export default Router;
--- src/navigation/StudentStack.tsx ---
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import HomeScreen from '../screens/student/Home/HomeScreen';
import QrScreen from '../screens/student/Qr/QrScreen';
import ProfileScreen from '../screens/student/Profile/ProfileScreen';

const Stack = createNativeStackNavigator();

const StudentStack = () => (
  <Stack.Navigator screenOptions={{ headerShown: false }}>
    <Stack.Screen name="HomeScreen" component={HomeScreen} options={{ animation: 'none' }} />
    <Stack.Screen name="QrScreen" component={QrScreen} options={{ animation: 'slide_from_bottom' }} />
    <Stack.Screen name="ProfileScreen" component={ProfileScreen} options={{ animation: 'ios_from_right' }} />
  </Stack.Navigator>
);

export default StudentStack;
--- src/navigation/types.ts ---
export type RootStackParamList = {
  Login: undefined;
  StudentHome: undefined;
  StudentProfile: undefined;
  StudentQr: undefined;
  AdminHome: undefined;
  Students: undefined;
  Courses: undefined;
  Attendance: undefined;
  StudentStack: undefined;
  AdminStack: undefined;
  AuthStack: undefined;
};

export type AdminTabParamList = {
  Home: undefined;
  Students: undefined;
  Courses: undefined;
  Attendance: undefined;
};
--- src/screens/admin/Attendance/Attendance.tsx ---
import React, {useState, useMemo, useEffect} from 'react';
import {
  View,
  Text,
  FlatList,
  TextInput,
  TouchableOpacity,
  Modal,
  ScrollView,
  SafeAreaView,
  Alert,
  ToastAndroid,
  Platform,
  ActivityIndicator,
  Image,
} from 'react-native';
import {Picker} from '@react-native-picker/picker';
import {Calendar, DateData} from 'react-native-calendars';
import XDate from 'xdate';
import {styles} from './styles';
import AttendanceQR from '../../../components/QR/AttendanceQr';
import {useData} from '../../../context/DataContext';
import * as DocumentPicker from '@react-native-documents/picker';
import RNFS from 'react-native-fs';
// @ts-ignore

const semesters = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];

// Add Student interface here for typing
interface Student {
  id: string;
  name: string;
  gender: 'Male' | 'Female' | 'Others';
  abcId: number;
  semester: number;
  batch: number;
  year: string;
  status: 'Active' | 'Inactive';
  course: string;
}

export default function Attendance() {
  const {
    fetchAttendanceData,
    attendanceData,
    studentsDataAll,
    courseData,
    fetchStudentsDataAll,
    fetchCourseData,
    markPresent,
    unmarkPresent,
    getMarkedStudents,
    saveAttendance,
    resetManualAttendance,
    latitude,
    longitude,
    hasExistingLocation,
  } = useData();

  const [searchTerm, setSearchTerm] = useState('');
  const [filterModalVisible, setFilterModalVisible] = useState(false);
  const [courseFilter, setCourseFilter] = useState('');
  const [batchFilter, setBatchFilter] = useState('');
  const [semesterFilter, setSemesterFilter] = useState('');
  const [dateFilter, setDateFilter] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [markModalVisible, setMarkModalVisible] = useState(false);
  const [markMethod, setMarkMethod] = useState('none');
  const [manualMarkingVisible, setManualMarkingVisible] = useState(false);
  const [saveDisabled, setSaveDisabled] = useState(false);
  const [manualMarkingCourseModalVisible, setManualMarkingCourseModalVisible] =
    useState(false);
  const [selectedManualMarkingCourse, setSelectedManualMarkingCourse] =
    useState('');
  const [holidayModalVisible, setHolidayModalVisible] = useState(false);
  const [holidays, setHolidays] = useState<Record<string, string>>({});
  const [importLoading, setImportLoading] = useState(false);
  const [visibleMonth, setVisibleMonth] = useState(new Date());
  const [selectedHoliday, setSelectedHoliday] = useState<{date: string; description: string} | null>(null);

  const [currentWeekStart, setCurrentWeekStart] = useState(() => {
    const today = new Date();
    const first = today.getDate() - today.getDay();
    const d = new Date(today);
    d.setDate(first);
    d.setHours(0, 0, 0, 0);
    return d;
  });

  const clearFilters = () => {
    setCourseFilter('');
    setBatchFilter('');
    setSemesterFilter('');
    setDateFilter(new Date());
    setSearchTerm('');
  };

  const filteredStudents = useMemo(() => {
    if (!Array.isArray(studentsDataAll)) {
      return [];
    }
    return studentsDataAll
      .map(doc => ({
        id: doc.$id,
        name: doc.Name,
        gender: doc.Gender,
        abcId: doc.ABC_ID,
        course: doc.Course?.$id || doc.Course, // Support both relation and string
        semester: doc.Semester,
        batch: doc.Batch,
        year: doc.Year,
        status: doc.Status,
      }))
      .filter(student => {
        const matchesSearch =
          student.name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
          String(student.abcId).includes(searchTerm);
        const matchesCourse = !courseFilter || student.course === courseFilter;
        const matchesBatch =
          !batchFilter || String(student.batch) === batchFilter;
        const matchesSemester =
          !semesterFilter || String(student.semester) === semesterFilter;
        return (
          matchesSearch && matchesCourse && matchesBatch && matchesSemester
        );
      });
  }, [studentsDataAll, searchTerm, courseFilter, batchFilter, semesterFilter]);

  const dateKey = `${dateFilter.getFullYear()}-${String(
    dateFilter.getMonth() + 1,
  ).padStart(2, '0')}-${String(dateFilter.getDate()).padStart(2, '0')}`;
  const attendanceToday = useMemo(() => {
    if (!Array.isArray(attendanceData)) {
      return [];
    }
    return attendanceData.filter(
      record => record.Marked_at?.slice(0, 10) === dateKey,
    );
  }, [attendanceData, dateKey]);

  useEffect(() => {
    setTimeout(() => {
      console.log('🔍 attendanceData:', attendanceData);
      console.log('🔍 dateKey:', dateKey);
      console.log('🔍 attendanceToday:', attendanceToday);
      console.log('🔍 filteredStudents:', filteredStudents);
    }, 2000);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    attendanceData,
    attendanceToday,
    dateKey,
    fetchAttendanceData,
    fetchCourseData,
    fetchStudentsDataAll,
    filteredStudents,
  ]);

  useEffect(() => {
    console.log('attendanceData updated:', attendanceData);
    console.log('attendanceToday:', attendanceToday);
    console.log('filteredStudents:', filteredStudents);

    // Add detailed logging of attendance records
    if (Array.isArray(attendanceToday)) {
      console.log('Detailed attendance records for today:');
      attendanceToday.forEach(record => {
        console.log(
          'Student ID:',
          typeof record.Student_Id === 'object'
            ? record.Student_Id.$id
            : record.Student_Id,
        );
        console.log('Status:', record.Status);
        console.log('Marked at:', record.Marked_at);
        console.log('---');
      });
    }
  }, [attendanceData, attendanceToday, filteredStudents]);

  const showToast = (message: string) => {
    if (Platform.OS === 'android') {
      ToastAndroid.show(message, ToastAndroid.SHORT);
    } else {
      Alert.alert('Info', message); // fallback for iOS
    }
  };
  const formatDate = (date: Date) => {
    return date.toLocaleDateString('en-GB', {
      day: 'numeric',
      month: 'short',
      year: 'numeric',
    });
  };

  const canEditDate = () => {
    const today = new Date();
    const selected = new Date(dateFilter);
    const diffInMs = today.setHours(0, 0, 0, 0) - selected.setHours(0, 0, 0, 0);
    const diffInDays = diffInMs / (1000 * 60 * 60 * 24);
    return diffInDays <= 0; // or `Infinity` if you want full editing capability
  };

  const handleMarkButtonPress = async () => {
    if (!canEditDate()) {
      ToastAndroid.show(
        'Previous Attendance is not allowed.',
        ToastAndroid.SHORT,
      );
      return;
    }
    if (!hasExistingLocation) {
      Alert.alert(
        'Location Required',
        'Please set up location in the Home screen before marking attendance.',
      );
      return;
    }
    setMarkModalVisible(true);
  };

  const handleQRGeneration = async () => {
    if (!canEditDate()) {
      ToastAndroid.show(
        'Previous Attendance is not allowed.',
        ToastAndroid.SHORT,
      );
      return;
    }
    if (!hasExistingLocation) {
      Alert.alert(
        'Location Required',
        'Please set up location in the Home screen before generating QR.',
      );
      return;
    }
    setMarkMethod('qr');
    setMarkModalVisible(false);
  };

  const getCourseName = (courseId: string) => {
    if (!courseData) {
      return '';
    }
    const courseObj = courseData.find((c: any) => c.$id === courseId);
    return courseObj ? courseObj.Programme : 'Unknown';
  };

  const renderCourseItem = ({item}: {item: any}) => {
    const courseStudents = filteredStudents.filter(
      student => student.course === item.$id,
    );
    const presentCount = attendanceToday.filter(
      record =>
        courseStudents.some(
          student =>
            (typeof record.Student_Id === 'object'
              ? record.Student_Id.$id
              : record.Student_Id) === student.id && record.Status === 'Present',
        ),
    ).length;

    return (
      <TouchableOpacity
        style={styles.courseItem}
        onPress={() => {
          setSelectedManualMarkingCourse(item.$id);
          setMarkModalVisible(true);
        }}>
        <View style={styles.courseItemContent}>
          <Text style={styles.courseName}>{item.Programme}</Text>
          <View style={styles.courseStats}>
            <Text style={styles.courseStatsText}>
              Present: {presentCount}/{courseStudents.length}
            </Text>
          </View>
        </View>
        <Image
          source={require('../../../assets/icons/right.png')}
          style={[styles.icon, styles.iconBlack]}
        />
      </TouchableOpacity>
    );
  };

  const renderManualMarkingItem = ({item}: {item: Student}) => {
    const backendMarked = attendanceToday.some(
      a =>
        (typeof a.Student_Id === 'object' ? a.Student_Id.$id : a.Student_Id) ===
          item.id && a.Status === 'Present',
    );
    const manuallyMarked = getMarkedStudents(dateKey).includes(item.id);
    const isMarked = backendMarked || manuallyMarked;

    const toggleAttendance = async () => {
      console.log('Toggling attendance for student:', item.id);
      console.log(
        'Current state - backendMarked:',
        backendMarked,
        'manuallyMarked:',
        manuallyMarked,
      );

      try {
        if (isMarked) {
          // If marked (either backend or manual), unmark it
          console.log('Unmarking attendance for student:', item.id);
          await unmarkPresent(item.id, dateKey);
          // Force refresh attendance data
          await fetchAttendanceData();
        } else {
          // If not marked, mark as present
          console.log('Marking student present:', item.id);
          markPresent(item.id, dateKey);
        }
      } catch (error) {
        console.error('Error toggling attendance:', error);
        Alert.alert('Error', 'Failed to update attendance');
      }
    };

    return (
      <TouchableOpacity
        style={styles.checkboxContainer}
        onPress={toggleAttendance}>
        <Text style={styles.checkboxLabel}>
          {item.name} ({getCourseName(item.course)}, Sem: {item.semester})
        </Text>
        <View style={styles.checkbox}>
          {isMarked && <View style={styles.checkboxInner} />}
        </View>
      </TouchableOpacity>
    );
  };
  const maxDate = new Date();

  const calendarModal = showDatePicker && (
    <Modal visible={showDatePicker} transparent animationType="fade">
      <View style={styles.modalOverlay}>
        <View style={styles.modalContent}>
          <View style={styles.modalHandle} />
          <Calendar
            current={dateFilter.toISOString().split('T')[0]}
            minDate={new Date(2020, 0, 1).toISOString().split('T')[0]}
            maxDate={new Date().toISOString().split('T')[0]}
            onDayPress={(day: DateData) => {
              const selectedDate = new Date(day.timestamp);
              const dayOfWeek = selectedDate.getDay();
              if (dayOfWeek === 0 || dayOfWeek === 6) {
                return;
              }
              const today = new Date();
              today.setHours(0, 0, 0, 0);
              if (selectedDate > today) {
                return;
              }

              // Check if the selected date is a holiday
              const dateKey = day.dateString;
              if (holidays[dateKey]) {
                setSelectedHoliday({date: dateKey, description: holidays[dateKey]});
                return;
              }

              setDateFilter(selectedDate);
              const newWeekStart = new Date(selectedDate);
              newWeekStart.setDate(selectedDate.getDate() - selectedDate.getDay());
              newWeekStart.setHours(0, 0, 0, 0);
              setCurrentWeekStart(newWeekStart);
              setShowDatePicker(false);
            }}
            markedDates={{
              [dateFilter.toISOString().split('T')[0]]: {
                selected: true,
                selectedColor: '#5271FF',
              },
              [new Date().toISOString().split('T')[0]]: {
                marked: true,
                dotColor: '#5271FF',
              },
              ...Object.keys(holidays).reduce((acc, date) => ({
                ...acc,
                [date]: {
                  marked: true,
                  dotColor: '#FF6B6B',
                  customStyles: {
                    container: {
                      backgroundColor: '#FFE5E5',
                      borderRadius: 16,
                    },
                    text: {
                      color: '#FF6B6B',
                    },
                  },
                },
              }), {}),
            }}
            disableAllTouchEventsForDisabledDays={true}
            onMonthChange={month => {
              setVisibleMonth(new Date(month.year, month.month - 1, 1));
            }}
            disableArrowRight={
              visibleMonth.getMonth() === new Date().getMonth() &&
              visibleMonth.getFullYear() === new Date().getFullYear()
            }
            renderHeader={date => (
              <Text style={styles.customHeader}>
                {date ? new XDate(date).toString('MMMM yyyy') : ''}
              </Text>
            )}
            dayComponent={props => {
              const dayOfWeek = new Date(props.date?.timestamp || 0).getDay();
              const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
              const isToday =
                new Date(props.date?.timestamp || 0).toDateString() ===
                new Date().toDateString();
              const isFuture =
                new Date(props.date?.timestamp || 0) > new Date();
              const isHoliday = props.date?.dateString && holidays[props.date.dateString];

              return (
                <View
                  style={[
                    styles.calendarDay,
                    isWeekend && styles.calendarDayWeekend,
                    isToday && styles.calendarDayToday,
                    isFuture && styles.calendarDayDisabled,
                    isHoliday && styles.calendarDayHoliday,
                  ]}>
                  <Text
                    style={[
                      styles.calendarDayText,
                      isWeekend && styles.calendarDayTextWeekend,
                      isToday && styles.calendarDayTextToday,
                      isFuture && styles.calendarDayTextDisabled,
                      isHoliday && styles.calendarDayTextHoliday,
                    ]}>
                    {props.date?.day}
                  </Text>
                </View>
              );
            }}
          />
          <TouchableOpacity
            style={[styles.cancelButton]}
            onPress={() => setShowDatePicker(false)}>
            <Text style={styles.cancelButtonText}>Close</Text>
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );

  // Holiday Details Modal
  const holidayDetailsModal = selectedHoliday && (
    <Modal visible={!!selectedHoliday} transparent animationType="fade">
      <View style={styles.modalOverlay}>
        <View style={styles.modalContent}>
          <View style={styles.modalHandle} />
          <Text style={styles.modalTitle}>Holiday Details</Text>
          <View style={styles.holidayDetailsContainer}>
            <Text style={styles.holidayDate}>
              {new Date(selectedHoliday.date).toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric',
              })}
            </Text>
            <Text style={styles.holidayDescription}>
              {selectedHoliday.description}
            </Text>
          </View>
          <TouchableOpacity
            style={[styles.cancelButton]}
            onPress={() => setSelectedHoliday(null)}>
            <Text style={styles.cancelButtonText}>Close</Text>
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );

  // Filtered students for manual marking (by selected course)
  const manualMarkingStudents = useMemo(() => {
    if (!Array.isArray(studentsDataAll)) return [];
    if (!selectedManualMarkingCourse) return [];
    return studentsDataAll
      .map(doc => ({
        id: doc.$id,
        name: doc.Name,
        gender: doc.Gender,
        abcId: doc.ABC_ID,
        course: doc.Course?.$id || doc.Course,
        semester: doc.Semester,
        batch: doc.Batch,
        year: doc.Year,
        status: doc.Status,
      }))
      .filter(student => student.course === selectedManualMarkingCourse);
  }, [studentsDataAll, selectedManualMarkingCourse]);

  // Helper to get week dates from a start date
  const getWeekDatesFromStart = (startDate: Date) => {
    const week = [];
    for (let i = 0; i < 7; i++) {
      const d = new Date(startDate);
      d.setDate(startDate.getDate() + i);
      d.setHours(0, 0, 0, 0);
      week.push(d);
    }
    return week;
  };

  const navigateWeek = (direction: 'prev' | 'next') => {
    const newWeekStart = new Date(currentWeekStart);
    newWeekStart.setDate(
      currentWeekStart.getDate() + (direction === 'next' ? 7 : -7),
    );
    setCurrentWeekStart(newWeekStart);
  };

  const handleImportHolidays = async () => {
    try {
      console.log('Starting holiday import...');
      const result = await DocumentPicker.pick({
        presentationStyle: 'fullScreen',
        type: [
          'text/csv',
          'text/comma-separated-values',
          'application/csv',
          '.csv',
        ],
        allowMultiSelection: false,
      });

      const file = result[0];
      console.log('Selected file:', file);

      if (!file.name?.toLowerCase().endsWith('.csv')) {
        Alert.alert('Error', 'Please select a CSV file');
        return;
      }

      let fileContent: string;
      if (Platform.OS === 'android') {
        const fileUri = file.uri;
        console.log('File URI:', fileUri);

        if (fileUri.startsWith('content://')) {
          const destPath = `${RNFS.TemporaryDirectoryPath}/${file.name}`;
          console.log('Copying file to:', destPath);
          await RNFS.copyFile(fileUri, destPath);
          fileContent = await RNFS.readFile(destPath);
          await RNFS.unlink(destPath);
        } else {
          fileContent = await RNFS.readFile(fileUri);
        }
      } else if (Platform.OS === 'ios') {
        fileContent = await RNFS.readFile(file.uri);
      } else {
        const response = await fetch(file.uri);
        fileContent = await response.text();
      }

      console.log('File content:', fileContent);

      // Parse CSV
      const lines = fileContent.split('\n').filter(line => line.trim() !== '');
      console.log('CSV lines:', lines);

      if (lines.length < 2) {
        throw new Error(
          'CSV file must contain at least a header row and one data row',
        );
      }

      const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
      console.log('CSV headers:', headers);

      const requiredHeaders = ['date', 'description'];
      const missingHeaders = requiredHeaders.filter(h => !headers.includes(h));

      if (missingHeaders.length > 0) {
        throw new Error(
          `Missing required headers: ${missingHeaders.join(', ')}`,
        );
      }

      const newHolidays: Record<string, string> = {};
      let added = 0;
      let errors: string[] = [];

      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',').map(v => v.trim());
        console.log(`Processing row ${i}:`, values);

        if (values.length !== headers.length) {
          errors.push(`Invalid number of columns in row ${i + 1}`);
          continue;
        }

        const date = values[headers.indexOf('date')];
        const description = values[headers.indexOf('description')];

        if (!date || !description) {
          errors.push(`Row ${i + 1}: Missing date or description`);
          continue;
        }

        try {
          const dateObj = new Date(date);
          if (isNaN(dateObj.getTime())) {
            errors.push(`Row ${i + 1}: Invalid date format: ${date}`);
            continue;
          }

          const dateKey = dateObj.toISOString().split('T')[0];
          newHolidays[dateKey] = description;
          added++;
          console.log(`Added holiday: ${dateKey} - ${description}`);
        } catch (e) {
          errors.push(
            `Row ${i + 1}: ${e instanceof Error ? e.message : 'Invalid date'}`,
          );
        }
      }

      console.log('Final holidays object:', newHolidays);

      if (added > 0) {
        setHolidays(newHolidays);
        showToast(`✅ Imported ${added} holidays successfully`);
        setHolidayModalVisible(false);
      }

      if (errors.length > 0) {
        Alert.alert(
          'Import Warnings',
          `Some rows had errors:\n${errors.join('\n')}`,
        );
      }
    } catch (err) {
      console.error('Import error:', err);
      const error = err as {code?: string};
      if (error.code !== 'DOCUMENT_PICKER_CANCELED') {
        Alert.alert(
          'Error',
          err instanceof Error ? err.message : 'Failed to import holidays',
        );
      }
    }
  };

  const downloadHolidayTemplate = async () => {
    try {
      const template = `date,description
2024-01-01,New Year
2024-12-25,Christmas`;

      const fileName = `holidays_template_${Date.now()}.csv`;
      let baseDir = '';
      if (Platform.OS === 'android') {
        baseDir = `${RNFS.DownloadDirectoryPath}/Attender/Holidays`;
      } else {
        baseDir = `${RNFS.DocumentDirectoryPath}/Attender/Holidays`;
      }

      await RNFS.mkdir(baseDir);
      const filePath = `${baseDir}/${fileName}`;
      await RNFS.writeFile(filePath, template, 'utf8');

      Alert.alert('Template Downloaded', `File saved to:\n${filePath}`);
    } catch (e) {
      Alert.alert(
        'Error',
        e instanceof Error ? e.message : 'Failed to download template',
      );
    }
  };

  const handleMarkAllAbsent = async () => {
    try {
      setSaveDisabled(true);
      console.log(
        'Marking all absent for course:',
        selectedManualMarkingCourse,
      );

      // Get all students in the course
      const courseStudents = manualMarkingStudents.map(student => student.id);
      console.log('Course student IDs:', courseStudents);

      // Get current attendance records for these students
      const courseAttendance = attendanceToday.filter(record => {
        const studentId =
          typeof record.Student_Id === 'object'
            ? record.Student_Id.$id
            : record.Student_Id;
        return courseStudents.includes(studentId);
      });
      console.log('Current attendance for course students:', courseAttendance);

      // First reset manual attendance for the date
      await resetManualAttendance(dateKey);

      // Unmark each student in the course
      for (const record of courseAttendance) {
        const studentId =
          typeof record.Student_Id === 'object'
            ? record.Student_Id.$id
            : record.Student_Id;
        console.log('Unmarking student:', studentId);
        await unmarkPresent(studentId, dateKey);
        // Add delay between operations
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      // Force refresh attendance data
      console.log('Fetching updated attendance data...');
      await fetchAttendanceData();
      console.log('Attendance data refreshed');

      setTimeout(() => setSaveDisabled(false), 1500);
      showToast(
        `🚫 All marked absent for ${getCourseName(
          selectedManualMarkingCourse,
        )} on ${formatDate(dateFilter)}`,
      );
    } catch (err) {
      console.error('Error marking all absent:', err);
      Alert.alert('Error', 'Failed to mark all absent.');
      setSaveDisabled(false);
    }
  };

  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const weekDates = getWeekDatesFromStart(currentWeekStart);

  // if (!attendanceData) {
  //   return (
  //     <SafeAreaView style={styles.container}>
  //       <View style={{flex:1,justifyContent:'center',alignItems:'center'}}>
  //         <ActivityIndicator size="large" color="#5271FF" />
  //         <Text>Loading attendance...</Text>
  //       </View>
  //     </SafeAreaView>
  //   );
  // }

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.searchContainer}>
        <Image
          source={require('../../../assets/icons/search.png')}
          style={[styles.icon, styles.iconBlack]}
        />
        <TextInput
          style={styles.searchInput}
          placeholder="Search by name..."
          value={searchTerm}
          onChangeText={setSearchTerm}
          placeholderTextColor="#A0AEC0"
        />
        <TouchableOpacity
          style={styles.filterButton}
          onPress={() => setFilterModalVisible(true)}>
          <Image
            source={require('../../../assets/icons/filter.png')}
            style={[styles.icon, styles.iconWhite]}
          />
        </TouchableOpacity>
      </View>

      {/* Date Selector */}
      <View style={styles.weekViewWrapper}>
        <View style={styles.weekViewHeader}>
          <View>
            <Text style={styles.weekViewTitle}>
              {dateFilter.toLocaleDateString('en-US', {month: 'long'})}
            </Text>
            <Text style={styles.weekViewSubtitle}>
              {dateFilter.toLocaleDateString('en-US', {year: 'numeric'})}
            </Text>
          </View>
          <TouchableOpacity
            style={styles.expandButton}
            onPress={() => setShowDatePicker(true)}>
            <Image
              source={require('../../../assets/icons/expand.png')}
              style={[styles.icon, styles.iconBlack]}
            />
          </TouchableOpacity>
        </View>

        <View style={styles.weekViewContent}>
          {weekDates.map(item => {
            const isSelected =
              item.toDateString() === dateFilter.toDateString();
            const isDisabled = item > today;
            return (
              <TouchableOpacity
                key={item.toDateString()}
                style={[
                  styles.weekViewDay,
                  isSelected && styles.weekViewDaySelected,
                  isDisabled && styles.weekViewDayDisabled,
                ]}
                disabled={isDisabled}
                onPress={() => {
                  if (!isDisabled) setDateFilter(new Date(item));
                }}>
                <Text
                  style={[
                    styles.weekViewDayText,
                    isSelected && styles.weekViewDaySelectedText,
                    isDisabled && styles.weekViewDayDisabledText,
                  ]}>
                  {item.toLocaleDateString('en-US', {weekday: 'short'})}
                </Text>
                <Text
                  style={[
                    styles.weekViewDayNumber,
                    isSelected && styles.weekViewDaySelectedText,
                    isDisabled && styles.weekViewDayDisabledText,
                  ]}>
                  {item.getDate()}
                </Text>
              </TouchableOpacity>
            );
          })}
        </View>
      </View>

      <View style={styles.dateContainer}>
        {/* <TouchableOpacity
          onPress={() => setShowDatePicker(true)}
          style={styles.datePickerButton}>
          <Text style={styles.calendarIcon}>📅</Text>
          <Text style={styles.filterLabel}>{dateFilter.toDateString()}</Text>
        </TouchableOpacity> */}

        <View style={styles.attendanceCountContainer}>
          <Text style={styles.attendanceCountText}>Present:</Text>
          <Text style={styles.attendanceCountNumber}>
            {attendanceToday.length}/{filteredStudents.length}
          </Text>
        </View>

        <TouchableOpacity
          style={styles.holidayButton}
          onPress={() => setHolidayModalVisible(true)}>
          <Text style={styles.holidayButtonText}>🎉 Holidays</Text>
        </TouchableOpacity>
      </View>

      {calendarModal}
      {holidayDetailsModal}

      {/* Holiday Import Modal */}
      <Modal visible={holidayModalVisible} animationType="slide" transparent>
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Manage Holidays</Text>

            <TouchableOpacity
              style={[styles.markAttendanceSection, {marginBottom: 12}]}
              onPress={handleImportHolidays}
              disabled={importLoading}>
              {importLoading ? (
                <ActivityIndicator color="white" />
              ) : (
                <Text style={styles.saveButtonText}>Import Holidays</Text>
              )}
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.markAttendanceSection, {marginBottom: 12}]}
              onPress={downloadHolidayTemplate}>
              <Text style={styles.saveButtonText}>Download Template</Text>
            </TouchableOpacity>

            {/* Display imported holidays */}
            {Object.keys(holidays).length > 0 && (
              <View style={{marginTop: 16}}>
                <Text style={[styles.filterSectionTitle, {marginBottom: 8}]}>
                  Imported Holidays:
                </Text>
                <ScrollView style={{maxHeight: 200}}>
                  {Object.entries(holidays).map(([date, description]) => (
                    <View
                      key={date}
                      style={{flexDirection: 'row', marginBottom: 4}}>
                      <Text style={{flex: 1}}>
                        {new Date(date).toLocaleDateString()}
                      </Text>
                      <Text style={{flex: 2}}>{description}</Text>
                    </View>
                  ))}
                </ScrollView>
              </View>
            )}

            <TouchableOpacity
              style={[
                styles.markAttendanceSection,
                styles.cancelButtonColor,
                {marginTop: 16},
              ]}
              onPress={() => setHolidayModalVisible(false)}>
              <Text style={styles.cancelButtonText}>Close</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Students List */}
      <FlatList
        data={courseData}
        keyExtractor={item => item.$id}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.listContent}
        ListFooterComponent={<View style={{height: 100}} />}
        renderItem={renderCourseItem}
        ListEmptyComponent={
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>
              No courses found. Try adjusting your filters.
            </Text>
          </View>
        }
      />

      {/* Filter Modal */}
      <Modal visible={filterModalVisible} animationType="slide" transparent>
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <ScrollView>
              <Text style={styles.modalTitle}>Filter Students</Text>

              <Text style={styles.filterSectionTitle}>Course</Text>
              <View style={styles.filterStudents}>
                <Picker
                  selectedValue={courseFilter}
                  onValueChange={value => setCourseFilter(value)}
                  style={styles.input}>
                  <Picker.Item label="All Courses" value="" />
                  {courseData?.map(course => (
                    <Picker.Item
                      key={course.$id}
                      label={course.Programme}
                      value={course.$id}
                    />
                  ))}
                </Picker>
              </View>

              <Text style={styles.filterSectionTitle}>Semester</Text>
              <View style={styles.filterStudents}>
                <Picker
                  selectedValue={semesterFilter}
                  onValueChange={value => setSemesterFilter(value)}
                  style={styles.input}>
                  <Picker.Item label="All Semesters" value="" />
                  {semesters.map(sem => (
                    <Picker.Item
                      key={sem}
                      label={sem.toString()}
                      value={sem.toString()}
                    />
                  ))}
                </Picker>
              </View>

              <View style={styles.modalButtons}>
                <TouchableOpacity
                  style={styles.cancelButton}
                  onPress={() => setFilterModalVisible(false)}>
                  <Text style={styles.cancelButtonText}>Close</Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={styles.saveButton}
                  onPress={() => {
                    setFilterModalVisible(false);
                  }}>
                  <Text style={styles.saveButtonText}>Apply</Text>
                </TouchableOpacity>
              </View>
              <TouchableOpacity
                style={styles.markAllButton}
                onPress={clearFilters}>
                <Text style={styles.markAllButtonText}>Clear All Filters</Text>
              </TouchableOpacity>
            </ScrollView>
          </View>
        </View>
      </Modal>

      {/* Mark Attendance Modal */}
      {canEditDate() && (
        <Modal visible={markModalVisible} animationType="slide" transparent>
          <View style={styles.modalOverlay}>
            <View style={styles.modalContent}>
              <Text style={styles.modalTitle}>
                Mark Attendance - {getCourseName(selectedManualMarkingCourse)}
              </Text>

              <TouchableOpacity
                style={[styles.markAttendanceSection]}
                onPress={() => {
                  setMarkModalVisible(false);
                  setManualMarkingVisible(true);
                }}>
                <Text style={styles.saveButtonText}>Mark Manually</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.markAttendanceSection]}
                onPress={handleQRGeneration}>
                <Text style={styles.saveButtonText}>Generate QR</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.markAttendanceSection, styles.cancelButtonColor]}
                onPress={() => setMarkModalVisible(false)}>
                <Text style={styles.cancelButtonText}>Cancel</Text>
              </TouchableOpacity>
            </View>
          </View>
        </Modal>
      )}

      {/* Manual Marking Course Selection Modal */}
      <Modal
        visible={manualMarkingCourseModalVisible}
        animationType="slide"
        transparent
        onRequestClose={() => setManualMarkingCourseModalVisible(false)}>
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <View style={styles.modalButtons}>
              <TouchableOpacity
                style={styles.cancelButton}
                onPress={() => setManualMarkingCourseModalVisible(false)}>
                <Text style={styles.cancelButtonText}>Cancel</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={styles.saveButton}
                disabled={!selectedManualMarkingCourse}
                onPress={() => {
                  setManualMarkingCourseModalVisible(false);
                  setManualMarkingVisible(true);
                }}>
                <Text style={styles.saveButtonText}>Continue</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Manual Marking Screen */}
      <Modal
        visible={manualMarkingVisible}
        animationType="slide"
        transparent
        onRequestClose={() => setManualMarkingVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <View style={styles.manualMarkingHeader}>
              <Text style={styles.modalTitle}>Mark Attendance</Text>
              <TouchableOpacity onPress={() => setManualMarkingVisible(false)}>
                <Text style={styles.crossStyle}>✕</Text>
              </TouchableOpacity>
            </View>
            <FlatList
              data={manualMarkingStudents}
              keyExtractor={item => item.id}
              renderItem={renderManualMarkingItem}
              ListEmptyComponent={
                <View style={styles.emptyContainer}>
                  <Text style={styles.emptyText}>
                    No students found for this course.
                  </Text>
                </View>
              }
            />
            <View style={styles.actionButtonsContainer}>
              <TouchableOpacity
                style={[styles.saveButton, styles.saveButtonAdd]}
                onPress={() => {
                  manualMarkingStudents.forEach(stu =>
                    markPresent(stu.id, dateKey),
                  );
                }}>
                <Text style={styles.saveButtonText}>Mark All Present</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.cancelButton, styles.cancelButtonAdd]}
                onPress={handleMarkAllAbsent}>
                <Text style={styles.cancelButtonText}>Mark All Absent</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[
                  styles.saveButton,
                  { marginTop: 12, opacity: saveDisabled ? 0.5 : 1 },
                ]}
                disabled={saveDisabled}
                onPress={async () => {
                  if (saveDisabled) {
                    return;
                  }
                  try {
                    await saveAttendance(
                      dateKey,
                      selectedManualMarkingCourse,
                      `attendance_${dateKey}`,
                      latitude ? Number(latitude) : null,
                      longitude ? Number(longitude) : null,
                    );
                    await fetchAttendanceData();
                    setManualMarkingVisible(false);
                    showToast(
                      `✅ Attendance saved for ${formatDate(dateFilter)}`,
                    );
                  } catch (err) {
                    Alert.alert(
                      'Error',
                      'Failed to save attendance. Please check required fields and try again.',
                    );
                    console.error(err);
                  }
                }}>
                <Text style={styles.saveButtonText}>Save Attendance</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* QR Code Overlay */}
      <Modal
        visible={markMethod === 'qr'}
        animationType="slide"
        transparent
        onRequestClose={() => setMarkMethod('none')}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>
              Scan this QR to mark attendance for {getCourseName(selectedManualMarkingCourse)}
            </Text>
            <AttendanceQR
              sessionId={`attendance_${dateKey}_${selectedManualMarkingCourse}`}
              selectedCourse={selectedManualMarkingCourse}
            />
            <TouchableOpacity
              onPress={() => setMarkMethod('none')}
              style={[styles.qrCloseButton, { marginTop: 24 }]}
            >
              <Text style={styles.saveButtonText}>Close</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
}
--- src/screens/admin/Attendance/styles.tsx ---
// src/screens/admin/Attendance/styles.tsx
import {StyleSheet} from 'react-native';
import {
  Colors,
  Fonts,
  Responsive,
  BorderRadius,
  Spacing,
} from '../../../globalStyles';

const {wp, hp, fontSize} = Responsive;

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.background,
  },
  header: {
    padding: hp(2),
  },
  headerTitle: {
    color: Colors.white,
    fontSize: fontSize.xl,
    fontFamily: Fonts.PFbold,
    marginBottom: hp(2),
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.round,
    padding: wp(1),
    paddingHorizontal: wp(3),
    margin: wp(4),
    marginTop: hp(3),
    borderWidth: 1,
    borderColor: Colors.border,
  },
  searchInput: {
    flex: 1,
    padding: wp(2.5),
    fontSize: fontSize.md,
    color: Colors.text,
    fontFamily: Fonts.PFregular,
    backgroundColor: 'transparent',
  },
  filterButton: {
    width: wp(10),
    height: wp(10),
    borderRadius: wp(5),
    backgroundColor: Colors.primary,
    justifyContent: 'center',
    alignItems: 'center',
    margin: wp(1),
  },
  filterIcon: {
    fontSize: fontSize.lg,
    color: Colors.white,
  },
  icon: {
    height: 24,
    width: 24,
  },
  iconBlack: {
    tintColor: 'black',
  },
  iconWhite: {
    tintColor: 'white',
  },
  dateContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginVertical: hp(2),
    paddingHorizontal: wp(4),
  },
  datePickerButton: {
    backgroundColor: Colors.white,
    paddingVertical: hp(1.5),
    paddingHorizontal: wp(3),
    borderRadius: BorderRadius.md,
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: Colors.border,
  },
  filterLabel: {
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
    color: Colors.text,
  },
  calendarIcon: {
    fontSize: fontSize.lg,
    color: Colors.primary,
    marginRight: wp(2),
  },
  listContent: {
    padding: wp(4),
  },
  studentItem: {
    backgroundColor: Colors.white,
    padding: wp(4),
    marginBottom: hp(2),
    borderRadius: BorderRadius.md,
    borderWidth: 1,
    borderColor: Colors.border,
    borderLeftWidth: 4,
    borderLeftColor: Colors.primary,
  },
  studentInfo: {
    fontSize: fontSize.sm,
    color: Colors.textLight,
    fontFamily: Fonts.PFregular,
    marginBottom: hp(0.5),
  },
  studentName: {
    fontSize: fontSize.lg,
    color: Colors.text,
    fontFamily: Fonts.PFmedium,
    marginBottom: hp(1),
  },
  presentBadge: {
    position: 'absolute',
    top: wp(2),
    right: wp(2),
    backgroundColor: Colors.success,
    paddingVertical: hp(0.5),
    paddingHorizontal: wp(2),
    borderRadius: BorderRadius.sm,
  },
  presentText: {
    color: Colors.white,
    fontSize: fontSize.xs,
    fontFamily: Fonts.PFbold,
  },
  absentBadge: {
    position: 'absolute',
    top: wp(2),
    right: wp(2),
    backgroundColor: Colors.error,
    paddingVertical: hp(0.5),
    paddingHorizontal: wp(2),
    borderRadius: BorderRadius.sm,
  },
  absentText: {
    color: Colors.white,
    fontSize: fontSize.xs,
    fontFamily: Fonts.PFbold,
  },
  notmarkBadge: {
    position: 'absolute',
    top: wp(2),
    right: wp(2),
    backgroundColor: Colors.warning,
    paddingVertical: hp(0.5),
    paddingHorizontal: wp(2),
    borderRadius: BorderRadius.sm,
  },
  notmarkText: {
    color: Colors.white,
    fontSize: fontSize.xs,
    fontFamily: Fonts.PFbold,
  },
  detailRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  detailsContainer: {
    flex: 1,
  },
  detailItem: {
    flexDirection: 'row',
    alignItems: 'center',
    minWidth: '45%',
    marginBottom: hp(1),
  },
  detailIcon: {
    fontSize: fontSize.md,
    color: Colors.primary,
    marginRight: wp(1),
    width: wp(5),
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: wp(6),
  },
  emptyText: {
    fontSize: fontSize.md,
    color: Colors.textLight,
    textAlign: 'center',
    fontFamily: Fonts.PFmedium,
  },
  modalOverlay: {
    flex: 1,
    justifyContent: 'flex-end',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalContent: {
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.xl,
    borderTopRightRadius: BorderRadius.xl,
    padding: wp(5),
    width: wp(90),
    maxHeight: hp(80),
    bottom: hp(3),
  },
  modalHandle: {
    width: 40,
    height: 4,
    backgroundColor: Colors.border,
    borderRadius: 2,
    alignSelf: 'center',
    marginBottom: hp(2),
  },
  modalTitle: {
    fontSize: fontSize.xl,
    fontFamily: Fonts.PFbold,
    color: Colors.text,
    marginBottom: hp(3),
    textAlign: 'center',
  },
  filterStudents: {
    borderRadius: 12,
    overflow: 'hidden',
    marginBottom: 15,
  },
  filterSectionTitle: {
    fontSize: fontSize.md,
    fontFamily: Fonts.PFbold,
    color: Colors.text,
    marginBottom: hp(1),
    marginTop: hp(2),
  },
  input: {
    borderWidth: 1,
    borderColor: Colors.border,
    borderRadius: BorderRadius.md,
    padding: wp(3),
    marginBottom: hp(2),
    fontSize: fontSize.md,
    color: Colors.text,
    fontFamily: Fonts.PFregular,
    backgroundColor: Colors.white,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: hp(3),
  },
  cancelButton: {
    padding: wp(4),
    borderRadius: BorderRadius.md,
    backgroundColor: Colors.background,
    flex: 1,
    marginRight: wp(2),
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderColor: Colors.border,
  },
  saveButton: {
    padding: wp(3),
    borderRadius: BorderRadius.md,
    backgroundColor: Colors.primary,
    flex: 1,
    marginLeft: wp(2),
    alignItems: 'center',
    justifyContent: 'center',
  },
  clearButton: {
    padding: wp(3),
    borderRadius: BorderRadius.md,
    backgroundColor: Colors.background,
    flex: 1,
    marginLeft: wp(2),
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderColor: Colors.error,
  },
  cancelButtonText: {
    color: Colors.text,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  saveButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  clearButtonText: {
    color: Colors.error,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  floatingAddButton: {
    position: 'absolute',
    bottom: hp(4),
    right: wp(5),
    width: wp(15),
    height: wp(15),
    backgroundColor: Colors.primary,
    borderRadius: wp(7.5),
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: `${Colors.primary}80`,
  },
  floatingAddButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFbold,
  },
  qrContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgb(254, 254, 254)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: wp(5),
    zIndex: 1000,
  },
  qrCloseButton: {
    backgroundColor: 'black',
    //   position: 'absolute',
    top: hp(4),
    //   right: wp(4),
    borderRadius: BorderRadius.md,
    padding: wp(2),
    alignItems: 'center',
    justifyContent: 'center',
    height: 48,
    width: '50%',
  },
  qrCloseIcon: {
    fontSize: fontSize.xl,
    color: Colors.text,
  },
  attendanceCountContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: wp(4),
    paddingVertical: hp(1),
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.md,
    borderWidth: 1,
    borderColor: Colors.border,
  },
  attendanceCountText: {
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
    color: Colors.text,
  },
  attendanceCountNumber: {
    fontSize: fontSize.md,
    fontFamily: Fonts.PFbold,
    color: Colors.primary,
  },
  divider: {
    height: 1,
    backgroundColor: Colors.border,
    marginVertical: hp(1),
  },
  markAllButton: {
    backgroundColor: Colors.primary,
    paddingVertical: hp(1.5),
    paddingHorizontal: wp(4),
    borderRadius: BorderRadius.md,
    marginTop: hp(2),
    alignSelf: 'center',
  },
  markAllButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  checkboxContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: wp(3),
    borderWidth: 1,
    borderColor: Colors.border,
    borderRadius: BorderRadius.md,
    marginBottom: hp(2),
    backgroundColor: Colors.white,
  },
  checkboxLabel: {
    flex: 1,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFregular,
    color: Colors.text,
  },
  checkbox: {
    width: wp(6),
    height: wp(6),
    borderWidth: 2,
    borderColor: Colors.primary,
    borderRadius: wp(1.5),
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: Colors.white,
  },
  checkboxInner: {
    width: wp(3),
    height: wp(3),
    borderRadius: wp(0.75),
    backgroundColor: Colors.primary,
  },
  manualMarkingContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: Colors.white,
    padding: wp(4),
    zIndex: 1000,
  },
  manualMarkingHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: hp(3),
    paddingBottom: hp(2),
    borderBottomWidth: 1,
    borderBottomColor: Colors.border,
  },
  actionButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: hp(3),
  },
  cancelButtonAdd: {
    flex: 0.48,
    marginLeft: 8,
  },
  markAttendanceSection: {
    marginBottom: 15,
    height: 48,
    backgroundColor: 'black',
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: 16,
  },
  cancelButtonColor: {
    backgroundColor: 'white',
    borderWidth: 0.8,
    borderColor: 'darkgray',
  },
  crossStyle: {
    fontSize: 20,
    color: 'red',
  },
  saveButtonAdd: {
    flex: 0.48,
  },
  holidayButton: {
    backgroundColor: Colors.primary,
    paddingVertical: hp(1.5),
    paddingHorizontal: wp(3),
    borderRadius: BorderRadius.md,
    alignItems: 'center',
    justifyContent: 'center',
    marginLeft: wp(2),
  },
  holidayButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  weekViewContainer: {
    width: '100%',
  },
  weekDaysContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: wp(2.5),
    width: '100%',
  },
  dayButton: {
    padding: wp(2),
    margin: wp(0.5),
    borderRadius: BorderRadius.md,
    alignItems: 'center',
    flex: 1,
  },
  dayButtonSelected: {
    backgroundColor: Colors.primary,
  },
  dayButtonDisabled: {
    backgroundColor: '#e0e0e0',
    opacity: 0.5,
  },
  dayButtonDefault: {
    backgroundColor: '#f0f0f0',
  },
  dayText: {
    fontSize: fontSize.xs,
    fontFamily: Fonts.PFregular,
  },
  dayNumber: {
    fontSize: fontSize.sm,
    fontFamily: Fonts.PFmedium,
  },
  dayTextSelected: {
    color: Colors.white,
    fontWeight: 'bold',
  },
  dayTextDisabled: {
    color: '#888',
  },
  dayTextDefault: {
    color: Colors.text,
  },
  expandButton: {
    alignItems: 'flex-end',
    height: 12,
    marginTop: 4,
  },
  loadingModalContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.3)',
  },
  loadingModalContent: {
    backgroundColor: 'white',
    padding: 24,
    borderRadius: 12,
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
  },
  weekViewWrapper: {
    marginVertical: hp(1),
  },
  weekViewHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: wp(2.5),
  },
  weekViewTitle: {
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
    color: Colors.text,
  },
  weekViewSubtitle: {
    fontSize: fontSize.sm,
    fontFamily: Fonts.PFregular,
    color: Colors.textLight,
  },
  weekViewContent: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: hp(1),
  },
  weekViewDay: {
    alignItems: 'center',
    flex: 1,
  },
  weekViewDayText: {
    fontSize: fontSize.xs,
    fontFamily: Fonts.PFregular,
    color: Colors.textLight,
    marginBottom: hp(0.5),
  },
  weekViewDayNumber: {
    fontSize: fontSize.sm,
    fontFamily: Fonts.PFmedium,
    color: Colors.text,
  },
  weekViewDaySelected: {
    backgroundColor: Colors.primary,
    borderRadius: BorderRadius.md,
    padding: wp(1),
  },
  weekViewDaySelectedText: {
    color: Colors.white,
  },
  weekViewDayDisabled: {
    opacity: 0.5,
  },
  weekViewDayDisabledText: {
    color: Colors.textLight,
  },
  customHeader: {
    fontSize: 32,
    fontWeight: '600',
    color: Colors.text,
    textAlign: 'center',
    fontFamily: Fonts.PFbold,
    marginVertical: Spacing.m,
  },
  calendarDay: {
    width: 32,
    height: 32,
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 16,
  },
  calendarDayWeekend: {
    opacity: 0.5,
  },
  calendarDayDisabled: {
    opacity: 0.3,
  },
  calendarDayText: {
    fontSize: fontSize.sm,
    fontFamily: Fonts.PFregular,
    color: Colors.text,
  },
  calendarDayTextWeekend: {
    color: Colors.error,
    opacity: 0.5,
  },
  calendarDayTextDisabled: {
    color: Colors.textLight,
  },
  calendarDayToday: {
    backgroundColor: Colors.primary,
    borderRadius: 16,
  },
  calendarDayTextToday: {
    color: Colors.white,
    fontFamily: Fonts.PFmedium,
  },
  calendarDayHoliday: {
    backgroundColor: '#FFE5E5',
    borderRadius: 16,
  },
  calendarDayTextHoliday: {
    color: '#FF6B6B',
    fontFamily: Fonts.PFmedium,
  },
  holidayDetailsContainer: {
    padding: wp(4),
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.md,
    marginBottom: hp(2),
  },
  holidayDate: {
    fontSize: fontSize.lg,
    fontFamily: Fonts.PFbold,
    color: Colors.text,
    marginBottom: hp(1),
  },
  holidayDescription: {
    fontSize: fontSize.md,
    fontFamily: Fonts.PFregular,
    color: Colors.text,
    lineHeight: 24,
  },
  courseItem: {
  backgroundColor: 'white',
  borderRadius: 12,
  padding: 16,
  marginBottom: 12,
  flexDirection: 'row',
  alignItems: 'center',
  justifyContent: 'space-between',
  shadowColor: '#000',
  shadowOffset: {
    width: 0,
    height: 2,
  },
  shadowOpacity: 0.1,
  shadowRadius: 3,
  elevation: 3,
},
courseItemContent: {
  flex: 1,
},
courseName: {
  fontSize: 16,
  fontWeight: '600',
  color: '#1A202C',
  marginBottom: 4,
},
courseStats: {
  flexDirection: 'row',
  alignItems: 'center',
},
courseStatsText: {
  fontSize: 14,
  color: '#4A5568',
},
});
--- src/screens/admin/Courses/Courses.tsx ---
import React, {useState, useMemo, useEffect} from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  TextInput,
  Modal,
  Alert,
  SafeAreaView,
  Platform,
  Image,
  ScrollView,
} from 'react-native';
import * as DocumentPicker from '@react-native-documents/picker';
import RNFS from 'react-native-fs';
import Share from 'react-native-share';
import {styles} from './styles';
import {useData} from '../../../context/DataContext';
import RNHTMLtoPDF from 'react-native-html-to-pdf';
import {Colors} from '../../../globalStyles';

interface Course {
  id: string;
  name: string;
  duration: string;
  status: 'Active' | 'Inactive';
}

export default function Courses() {
  const [searchTerm, setSearchTerm] = useState('');
  const [statusFilter, setStatusFilter] = useState<
    'all' | 'Active' | 'Inactive'
  >('all');
  const [modalVisible, setModalVisible] = useState(false);
  const [filterModalVisible, setFilterModalVisible] = useState(false);
  const [addMethodModalVisible, setAddMethodModalVisible] = useState(false);
  const [manualAddModalVisible, setManualAddModalVisible] = useState(false);
  const [exportModalVisible, setExportModalVisible] = useState(false);
  const [exportFormat, setExportFormat] = useState<'csv' | 'json' | 'pdf'>(
    'csv',
  );
  const [exportStatusFilter, setExportStatusFilter] = useState<
    'all' | 'Active' | 'Inactive'
  >('all');

  const [courseName, setCourseName] = useState('');
  const [duration, setDuration] = useState('');
  const [status, setStatus] = useState<'Active' | 'Inactive'>('Active');
  const [editingId, setEditingId] = useState<string | null>(null);

  const [selectedCourse, setSelectedCourse] = useState<Course | null>(null);
  const [detailsModalVisible, setDetailsModalVisible] = useState(false);

  const {courseData, fetchCourseData, addCourse, updateCourse, deleteCourse} =
    useData();

  useEffect(() => {
    console.log('📞 Fetching course data...');
    fetchCourseData();
  }, []);

  const resetForm = () => {
    setCourseName('');
    setDuration('');
    setStatus('Active');
    setEditingId(null);
  };

  const handleAddOrEditCourse = async () => {
    if (!courseName || !duration) {
      Alert.alert('Error', 'Please fill all fields');
      return;
    }

    const cleanedName = courseName.replace(/\s+/g, '').toLowerCase();
    const parsedDuration = parseInt(duration, 10);

    const isDuplicate = courseData?.some(
      course =>
        course.Programme.replace(/\s+/g, '').toLowerCase() === cleanedName &&
        course.Duration === parsedDuration &&
        course.$id !== editingId,
    );

    if (isDuplicate) {
      Alert.alert(
        'Duplicate Course',
        'This course with the same duration already exists.',
      );
      return;
    }

    if (editingId) {
      await updateCourse(editingId, courseName, parsedDuration, status);
    } else {
      await addCourse(courseName, parsedDuration, status);
    }

    resetForm();
    setManualAddModalVisible(false);
    fetchCourseData();
  };

  const handleFileUpload = async () => {
    try {
      const result = await DocumentPicker.pick({
        presentationStyle: 'fullScreen',
        type: [
          'application/json',
          'text/csv',
          'text/comma-separated-values',
          'application/csv',
          '.csv',
          '.json',
        ],
        allowMultiSelection: false,
      });

      const file = result[0];
      if (
        !file.name?.toLowerCase().endsWith('.json') &&
        !file.name?.toLowerCase().endsWith('.csv')
      ) {
        Alert.alert('Error', 'Please select a JSON or CSV file');
        return;
      }

      try {
        let fileContent: string;

        if (Platform.OS === 'android') {
          const fileUri = file.uri;
          if (fileUri.startsWith('content://')) {
            const destPath = `${RNFS.TemporaryDirectoryPath}/${file.name}`;
            await RNFS.copyFile(fileUri, destPath);
            fileContent = await RNFS.readFile(destPath);
            await RNFS.unlink(destPath);
          } else {
            fileContent = await RNFS.readFile(fileUri);
          }
        } else if (Platform.OS === 'ios') {
          fileContent = await RNFS.readFile(file.uri);
        } else {
          const response = await fetch(file.uri);
          fileContent = await response.text();
        }

        let courses;
        if (file.name.toLowerCase().endsWith('.json')) {
          courses = JSON.parse(fileContent);
        } else {
          // Parse CSV
          const lines = fileContent
            .split('\n')
            .filter(line => line.trim() !== '');
          if (lines.length < 2) {
            throw new Error(
              'CSV file must contain at least a header row and one data row',
            );
          }

          const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
          const requiredHeaders = ['name', 'duration'];
          const missingHeaders = requiredHeaders.filter(
            h => !headers.includes(h),
          );

          if (missingHeaders.length > 0) {
            throw new Error(
              `Missing required headers: ${missingHeaders.join(', ')}`,
            );
          }

          courses = lines.slice(1).map((line, index) => {
            const values = line.split(',').map(v => v.trim());
            if (values.length !== headers.length) {
              throw new Error(`Invalid number of columns in row ${index + 2}`);
            }

            const course: any = {};
            headers.forEach((header, i) => {
              if (header === 'name') {
                course.name = values[i];
              } else if (header === 'duration') {
                const duration = parseInt(values[i], 10);
                if (isNaN(duration) || duration <= 0) {
                  throw new Error(
                    `Invalid duration in row ${index + 2}: ${values[i]}`,
                  );
                }
                course.duration = duration;
              } else if (header === 'status') {
                const status = values[i].trim();
                if (status && status !== 'Active' && status !== 'Inactive') {
                  throw new Error(
                    `Invalid status in row ${index + 2}: ${status}`,
                  );
                }
                course.status = status || 'Active';
              }
            });

            return course;
          });
        }

        if (!Array.isArray(courses)) {
          throw new Error('File must contain an array of courses');
        }

        if (courses.length === 0) {
          throw new Error('No valid courses found in the file');
        }

        // Validate and add each course
        for (const course of courses) {
          if (!course.name || !course.duration) {
            throw new Error('Each course must have a name and duration');
          }

          // Check for duplicates before adding
          const cleanedName = course.name.replace(/\s+/g, '').toLowerCase();
          const isDuplicate = courseData?.some(
            existingCourse =>
              existingCourse.Programme.replace(/\s+/g, '').toLowerCase() ===
                cleanedName && existingCourse.Duration === course.duration,
          );

          if (isDuplicate) {
            throw new Error(
              `Duplicate course found: ${course.name} with duration ${course.duration} months`,
            );
          }

          await addCourse(
            course.name,
            course.duration,
            course.status || 'Active',
          );
        }

        Alert.alert('Success', 'Courses imported successfully');
        setAddMethodModalVisible(false);
        fetchCourseData();
      } catch (e) {
        if (e instanceof Error) {
          Alert.alert('Error', `Invalid file format: ${e.message}`);
        } else {
          Alert.alert('Error', 'Invalid file format');
        }
      }
    } catch (err) {
      const error = err as {code?: string};
      if (error.code !== 'DOCUMENT_PICKER_CANCELED') {
        Alert.alert('Error', 'Failed to read file');
      }
    }
  };

  const handleDeleteCourse = (id: string) => {
    Alert.alert(
      'Confirm Delete',
      'Are you sure you want to delete this course?',
      [
        {text: 'Cancel', style: 'cancel'},
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            await deleteCourse(id);
            fetchCourseData();
          },
        },
      ],
    );
  };

  const handleEditCourse = (course: Course) => {
    setCourseName(course.name);
    setDuration(String(course.duration));
    setStatus(course.status);
    setEditingId(course.id);
    setManualAddModalVisible(true);
  };

  const filteredCourses = useMemo((): Course[] => {
    if (!Array.isArray(courseData)) {
      return [];
    }

    return courseData
      .map(doc => ({
        id: doc.$id,
        name: doc.Programme ?? '',
        duration: doc.Duration ?? '',
        status: doc.Status ?? 'Inactive',
      }))
      .filter(course => {
        const matchesSearch = course.name
          .toLowerCase()
          .includes(searchTerm.toLowerCase());
        const matchesStatus =
          statusFilter === 'all' || course.status === statusFilter;
        return matchesSearch && matchesStatus;
      });
  }, [courseData, searchTerm, statusFilter]);

  const renderCourseItem = ({item}: {item: Course}) => (
    <TouchableOpacity
      style={[
        styles.courseItem,
        item.status === 'Inactive' && styles.disabledItem,
      ]}
      onPress={() => {
        setSelectedCourse(item);
        setDetailsModalVisible(true);
      }}>
      <View style={styles.courseItemContent}>
        <View style={styles.courseInfo}>
          <View style={{flexDirection: 'row', alignItems: 'center'}}>
            <Text style={styles.courseName}>{item.name}</Text>
          </View>
          <Text style={styles.courseDetails}>
            Duration: {item.duration} months
          </Text>
        </View>
        <View>
          <View
            style={[
              styles.statusIndicator,
              item.status === 'Active'
                ? styles.statusActive
                : styles.statusInactive,
            ]}
          />
        </View>
      </View>
    </TouchableOpacity>
  );

  const renderDetailsModal = () => {
    if (!selectedCourse) {
      return null;
    }

    return (
      <Modal
        visible={detailsModalVisible}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setDetailsModalVisible(false)}>
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <View style={styles.modalHandle} />
            <Text style={styles.modalTitle}>Course Details</Text>
            <TouchableOpacity
              onPress={() => setDetailsModalVisible(false)}
              style={styles.closeButton}>
              <Text style={styles.closeButtonText}>×</Text>
            </TouchableOpacity>

            <ScrollView showsVerticalScrollIndicator={false}>
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Name:</Text>
                <Text style={styles.detailValue}>{selectedCourse.name}</Text>
              </View>
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Duration:</Text>
                <Text style={styles.detailValue}>
                  {selectedCourse.duration} months
                </Text>
              </View>
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Status:</Text>
                <Text
                  style={[
                    styles.detailValue,
                    {
                      color:
                        selectedCourse.status === 'Active'
                          ? Colors.success
                          : Colors.error,
                    },
                  ]}>
                  {selectedCourse.status}
                </Text>
              </View>
            </ScrollView>

            <View style={styles.modalActions}>
              <TouchableOpacity
                style={[styles.modalButton, {backgroundColor: Colors.primary}]}
                onPress={() => {
                  setDetailsModalVisible(false);
                  handleEditCourse(selectedCourse);
                }}>
                <Image
                  source={require('../../../assets/icons/edit.png')}
                  style={[styles.icon, styles.iconWhite]}
                />
                <Text style={[styles.modalButtonText, {color: Colors.white}]}>
                  Edit
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.modalButton, {backgroundColor: Colors.error}]}
                onPress={() => {
                  setDetailsModalVisible(false);
                  handleDeleteCourse(selectedCourse.id);
                }}>
                <Image
                  source={require('../../../assets/icons/delete.png')}
                  style={[styles.icon, styles.iconWhite]}
                />
                <Text style={[styles.modalButtonText, {color: Colors.white}]}>
                  Delete
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    );
  };

  const exportImmediately = async (
    format: 'csv' | 'pdf',
    action: 'download' | 'share',
  ) => {
    try {
      // Filter courses based on exportStatusFilter
      let exportCourses = courseData || [];
      if (exportStatusFilter !== 'all') {
        exportCourses = exportCourses.filter(
          (doc: any) => doc.Status === exportStatusFilter,
        );
      }
      if (!exportCourses.length) {
        Alert.alert('No courses to export');
        setExportModalVisible(false);
        return;
      }
      let fileContent = '';
      let fileName = `courses_export_${Date.now()}`;
      let filePath = '';
      let baseDir = '';
      if (Platform.OS === 'android') {
        baseDir = `${RNFS.DownloadDirectoryPath}/Attender/courses`;
      } else {
        baseDir = `${RNFS.DocumentDirectoryPath}/Attender/courses`;
      }
      await RNFS.mkdir(baseDir);
      if (format === 'csv') {
        const headers = ['Programme', 'Duration', 'Status'];
        const rows = exportCourses.map((c: any) => [
          c.Programme,
          c.Duration,
          c.Status,
        ]);
        fileContent = [headers.join(','), ...rows.map(r => r.join(','))].join(
          '\n',
        );
        fileName += '.csv';
        filePath = `${baseDir}/${fileName}`;
        await RNFS.writeFile(filePath, fileContent, 'utf8');
      } else if (format === 'pdf') {
        const headers = ['Programme', 'Duration', 'Status'];
        const rowsHtml = exportCourses
          .map(
            c =>
              `<tr><td>${c.Programme}</td><td>${c.Duration}</td><td>${c.Status}</td></tr>`,
          )
          .join('');
        const html = `
          <h2>Courses Export</h2>
          <table border="1" style="border-collapse:collapse;width:100%">
            <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
            ${rowsHtml}
          </table>
        `;
        fileName += '.pdf';
        // 1. Generate PDF in default location
        const pdf = await RNHTMLtoPDF.convert({
          html,
          fileName: fileName.replace('.pdf', ''),
          base64: false,
        });
        // 2. Move PDF to Downloads/Attender/courses/
        const targetPath = `${baseDir}/${fileName}`;
        await RNFS.mkdir(baseDir);
        await RNFS.moveFile(pdf.filePath, targetPath);
        filePath = targetPath;
      }
      if (action === 'download') {
        Alert.alert('Export Complete', `File saved to:\n${filePath}`);
      } else if (action === 'share') {
        await Share.open({
          url: Platform.OS === 'android' ? `file://${filePath}` : filePath,
          type: format === 'pdf' ? 'application/pdf' : 'text/csv',
          failOnCancel: false,
        });
      }
    } catch (e) {
      Alert.alert(
        'Export Error',
        e instanceof Error ? e.message : 'Failed to export',
      );
    } finally {
      setExportModalVisible(false);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.searchContainer}>
        <Image
          source={require('../../../assets/icons/search.png')}
          style={[styles.icon, styles.iconBlack]}
        />
        <TextInput
          style={styles.searchInput}
          placeholder="Search courses..."
          value={searchTerm}
          onChangeText={setSearchTerm}
          placeholderTextColor="#A0AEC0"
        />
        <TouchableOpacity
          style={styles.filterButton}
          onPress={() => setFilterModalVisible(true)}>
          <Image
            source={require('../../../assets/icons/filter.png')}
            style={[styles.icon, styles.iconWhite]}
          />
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.filterButton, {backgroundColor: Colors.success}]}
          onPress={() => setExportModalVisible(true)}>
          <Image
            source={require('../../../assets/icons/export.png')}
            style={[styles.icon, styles.iconWhite]}
          />
        </TouchableOpacity>
      </View>

      {filteredCourses.length === 0 ? (
        <View style={styles.emptyContainer}>
          <Text style={styles.emptyText}>No courses found</Text>
          <TouchableOpacity
            style={styles.addButton}
            onPress={() => {
              resetForm();
              setAddMethodModalVisible(true);
            }}>
            <Text style={styles.addButtonText}>Add New Course</Text>
          </TouchableOpacity>
        </View>
      ) : (
        <FlatList
          data={filteredCourses}
          renderItem={renderCourseItem}
          keyExtractor={item => item.id}
          contentContainerStyle={styles.listContent}
          ListFooterComponent={<View style={{height: 100}} />}
        />
      )}

      <TouchableOpacity
        style={styles.floatingAddButton}
        onPress={() => {
          resetForm();
          setAddMethodModalVisible(true);
        }}>
        <Image
          source={require('../../../assets/icons/add.png')}
          style={[styles.icon, styles.iconWhite]}
        />
      </TouchableOpacity>

      {/* Add Method Selection Modal */}
      <Modal
        visible={addMethodModalVisible}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setAddMethodModalVisible(false)}>
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Add Course</Text>
            <TouchableOpacity
              style={styles.methodButton}
              onPress={() => {
                setAddMethodModalVisible(false);
                setManualAddModalVisible(true);
              }}>
              <Text style={styles.methodButtonText}>Add Manually</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.methodButton}
              onPress={handleFileUpload}>
              <Text style={styles.methodButtonText}>Upload CSV/JSON File</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.cancelButtonExport}
              onPress={() => setAddMethodModalVisible(false)}>
              <Text style={styles.cancelButtonText}>Cancel</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Manual Add/Edit Modal */}
      <Modal
        visible={manualAddModalVisible}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setManualAddModalVisible(false)}>
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>
              {editingId ? 'Edit Course' : 'Add Course'}
            </Text>
            <TextInput
              style={styles.input}
              placeholder="Course Name"
              value={courseName}
              onChangeText={setCourseName}
            />
            <TextInput
              style={styles.input}
              placeholder="Duration (months)"
              value={duration}
              onChangeText={setDuration}
              keyboardType="numeric"
            />
            <Text style={styles.filterSectionTitle}>Status</Text>
            <View style={styles.statusOptions}>
              {['Active', 'Inactive'].map(s => (
                <TouchableOpacity
                  key={s}
                  style={[
                    styles.statusOption,
                    status === s && styles.statusOptionSelected,
                  ]}
                  onPress={() => setStatus(s as 'Active' | 'Inactive')}>
                  <Text
                    style={[
                      styles.statusOptionText,
                      status === s && styles.statusOptionTextSelected,
                    ]}>
                    {s}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
            <View style={styles.modalButtons}>
              <TouchableOpacity
                style={styles.cancelButton}
                onPress={() => setManualAddModalVisible(false)}>
                <Text style={styles.cancelButtonText}>Cancel</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={styles.saveButton}
                onPress={handleAddOrEditCourse}>
                <Text style={styles.saveButtonText}>
                  {editingId ? 'Update' : 'Save'}
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Filter Modal */}
      <Modal
        visible={filterModalVisible}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setFilterModalVisible(false)}>
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Filter by Status</Text>
            {['all', 'Active', 'Inactive'].map(option => (
              <TouchableOpacity
                key={option}
                style={[
                  styles.filterOption,
                  statusFilter === option && styles.filterOptionSelected,
                ]}
                onPress={() => {
                  setStatusFilter(option as 'all' | 'Active' | 'Inactive');
                  setFilterModalVisible(false);
                }}>
                <Text
                  style={[
                    styles.filterOptionText,
                    statusFilter === option && styles.filterOptionTextSelected,
                  ]}>
                  {option === 'all' ? 'All Courses' : option}
                </Text>
              </TouchableOpacity>
            ))}
            <TouchableOpacity
              style={styles.markAllButton}
              onPress={() => {
                setStatusFilter('all');
                setSearchTerm('');
                setFilterModalVisible(false);
              }}>
              <Text style={styles.markAllButtonText}>Clear All Filters</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Export Modal */}
      <Modal
        visible={exportModalVisible}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setExportModalVisible(false)}>
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Export Courses</Text>
            <Text style={styles.filterSectionTitle}>Filter by Status</Text>
            {['all', 'Active', 'Inactive'].map(option => (
              <TouchableOpacity
                key={option}
                style={[
                  styles.filterOption,
                  exportStatusFilter === option && styles.filterOptionSelected,
                ]}
                onPress={() =>
                  setExportStatusFilter(option as 'all' | 'Active' | 'Inactive')
                }>
                <Text
                  style={[
                    styles.filterOptionText,
                    exportStatusFilter === option &&
                      styles.filterOptionTextSelected,
                  ]}>
                  {option === 'all' ? 'All Courses' : option}
                </Text>
              </TouchableOpacity>
            ))}
            <Text style={styles.filterSectionTitle}>Export Format</Text>
            <View style={styles.exportFormatRow}>
              {[
                {type: 'csv', label: 'CSV'},
                {type: 'pdf', label: 'PDF'},
              ].map(fmt => (
                <View key={fmt.type} style={styles.exportFormatCardStatic}>
                  <Text style={styles.exportFormatLabelStatic}>
                    {fmt.label}
                  </Text>
                  <View style={styles.exportFormatActions}>
                    <TouchableOpacity
                      style={styles.exportShareIconBtn}
                      onPress={() =>
                        exportImmediately(fmt.type as 'csv' | 'pdf', 'share')
                      }>
                      <Image
                        source={require('../../../assets/icons/share.png')}
                        style={styles.exportShareIcon}
                      />
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={styles.exportDownloadIconBtn}
                      onPress={() =>
                        exportImmediately(fmt.type as 'csv' | 'pdf', 'download')
                      }>
                      <Image
                        source={require('../../../assets/icons/download.png')}
                        style={styles.exportDownloadIcon}
                      />
                    </TouchableOpacity>
                  </View>
                </View>
              ))}
            </View>
            <View style={styles.modalButtons}>
              <TouchableOpacity
                style={styles.cancelButton}
                onPress={() => setExportModalVisible(false)}>
                <Text style={styles.cancelButtonText}>Cancel</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {renderDetailsModal()}
    </SafeAreaView>
  );
}
--- src/screens/admin/Courses/styles.tsx ---
import {StyleSheet} from 'react-native';
import {Colors, Fonts, Responsive, BorderRadius} from '../../../globalStyles';

const {wp, hp, fontSize} = Responsive;

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.background,
  },
  pageTitle: {
    fontSize: fontSize.xl,
    fontFamily: Fonts.PFbold,
    color: Colors.text,
    marginHorizontal: wp(4),
    marginTop: hp(2),
    marginBottom: hp(2),
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.round,
    padding: wp(1),
    paddingHorizontal: wp(3),
    margin: wp(4),
    marginTop: hp(3),
    borderWidth: 1,
    borderColor: Colors.border,
  },
  searchInput: {
    flex: 1,
    padding: wp(2.5),
    fontSize: fontSize.md,
    color: Colors.text,
    fontFamily: Fonts.PFregular,
    backgroundColor: 'transparent',
  },
  filterButton: {
    width: wp(10),
    height: wp(10),
    borderRadius: wp(5),
    backgroundColor: Colors.primary,
    justifyContent: 'center',
    alignItems: 'center',
    margin: wp(1),
  },
  filterIcon: {
    fontSize: fontSize.lg,
    color: Colors.white,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: wp(4),
  },
  emptyText: {
    fontSize: fontSize.md,
    color: Colors.textLight,
    marginBottom: hp(2.5),
    fontFamily: Fonts.PFmedium,
  },
  addButton: {
    backgroundColor: Colors.primary,
    paddingVertical: hp(1.5),
    paddingHorizontal: wp(6),
    borderRadius: BorderRadius.md,
    marginTop: hp(2),
  },
  addButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  floatingAddButton: {
    position: 'absolute',
    bottom: hp(4),
    right: wp(5),
    width: wp(15),
    height: wp(15),
    backgroundColor: Colors.primary,
    borderRadius: wp(7.5),
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: `${Colors.primary}80`,
  },
  floatingAddButtonText: {
    color: Colors.white,
    fontSize: fontSize.xxl,
    fontFamily: Fonts.PFbold,
  },
  listContent: {
    paddingHorizontal: wp(4),
  },
  courseItem: {
    flexDirection: 'row',
    backgroundColor: Colors.white,
    padding: wp(3),
    borderRadius: BorderRadius.lg,
    marginBottom: hp(1),
    borderWidth: 1,
    borderColor: Colors.border,
  },
  disabledItem: {
    borderLeftColor: '#EF4444',
    opacity: 0.8,
  },
  avatar: {
    width: wp(10),
    height: wp(10),
    borderRadius: wp(5),
    backgroundColor: Colors.background,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: wp(4),
  },
  avatarText: {
    fontSize: fontSize.lg,
    color: Colors.text,
    fontFamily: Fonts.PFbold,
  },
  courseItemContent: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
  },
  courseInfo: {
    flex: 1,
  },
  courseName: {
    fontSize: fontSize.lg,
    color: Colors.text,
    marginBottom: hp(0.5),
    fontFamily: Fonts.PFbold,
  },
  courseNameContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  statusDot: {
    width: wp(3),
    height: wp(3),
    borderRadius: wp(1.5),
    marginRight: wp(2),
  },
  statusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: hp(0.5),
  },
  courseDetails: {
    fontSize: fontSize.sm,
    color: Colors.textLight,
    fontFamily: Fonts.PFregular,
  },
  statusIndicator: {
    width: wp(3),
    height: wp(3),
    borderRadius: wp(1.5),
    marginRight: wp(2),
  },
  statusText: {
    fontSize: fontSize.sm,
    color: Colors.textLight,
    fontFamily: Fonts.PFregular,
  },
  courseDuration: {
    fontSize: fontSize.sm,
    color: Colors.textLight,
    fontFamily: Fonts.PFregular,
    marginBottom: hp(0.5),
  },
  statusActive: {
    backgroundColor: Colors.success,
  },
  statusInactive: {
    backgroundColor: Colors.error,
  },
  actionButtons: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  editButton: {
    padding: wp(2),
    marginRight: wp(2),
  },
  deleteButton: {
    padding: wp(2),
  },
  editIcon: {
    fontSize: fontSize.lg,
    color: Colors.primary,
  },
  deleteIcon: {
    fontSize: fontSize.lg,
    color: Colors.error,
  },
  modalOverlay: {
    flex: 1,
    justifyContent: 'flex-end',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.64)',
  },
  modalContent: {
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.xl,
    borderTopRightRadius: BorderRadius.xl,
    padding: wp(5),
    width: wp(90),
    maxHeight: hp(80),
    bottom: hp(3),
  },
  modalHandle: {
    width: 40,
    height: 4,
    backgroundColor: Colors.border,
    borderRadius: 2,
    alignSelf: 'center',
    marginBottom: hp(2),
  },
  modalTitle: {
    fontSize: fontSize.xl,
    color: Colors.text,
    marginBottom: hp(2.5),
    fontFamily: Fonts.PFbold,
    textAlign: 'center',
  },
  detailRow: {
    flexDirection: 'row',
    paddingVertical: hp(1),
    borderBottomWidth: 1,
    borderBottomColor: Colors.border,
  },
  detailLabel: {
    flex: 1,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
    color: Colors.text,
  },
  detailValue: {
    flex: 2,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFregular,
    color: Colors.text,
  },
  input: {
    borderWidth: 1,
    borderColor: Colors.border,
    borderRadius: BorderRadius.md,
    padding: wp(3),
    marginBottom: hp(2),
    fontSize: fontSize.md,
    color: Colors.text,
    fontFamily: Fonts.PFregular,
  },
  filterSectionTitle: {
    fontSize: fontSize.md,
    fontFamily: Fonts.PFbold,
    color: Colors.text,
    marginBottom: hp(1),
    marginTop: hp(1),
  },
  statusOptions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: hp(3),
  },
  statusOption: {
    flex: 1,
    padding: wp(3),
    borderRadius: BorderRadius.md,
    backgroundColor: Colors.background,
    alignItems: 'center',
    marginHorizontal: wp(1),
    borderWidth: 1,
    borderColor: Colors.border,
  },
  statusOptionSelected: {
    backgroundColor: Colors.primary,
    borderColor: Colors.primary,
  },
  statusOptionText: {
    color: Colors.text,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  statusOptionTextSelected: {
    color: Colors.white,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: hp(2),
  },
  cancelButton: {
    padding: wp(3),
    borderRadius: BorderRadius.md,
    backgroundColor: Colors.background,
    flex: 1,
    marginRight: wp(2),
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderColor: Colors.border,
  },
  cancelButtonExport: {
    borderRadius: BorderRadius.md,
    backgroundColor: Colors.background,
    borderWidth: 1,
    borderColor: Colors.border,
    paddingVertical: hp(2),
    paddingHorizontal: wp(4),
    marginBottom: hp(2),
    alignItems: 'center',
  },
  saveButton: {
    padding: wp(3),
    borderRadius: BorderRadius.md,
    backgroundColor: Colors.primary,
    flex: 1,
    marginLeft: wp(2),
    alignItems: 'center',
    justifyContent: 'center',
  },
  buttonText: {
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  cancelButtonText: {
    color: Colors.text,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  saveButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  deleteButtonText: {
    color: Colors.error,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  filterOption: {
    padding: wp(3),
    borderRadius: BorderRadius.md,
    backgroundColor: Colors.white,
    marginBottom: hp(1.25),
    borderWidth: 1,
    borderColor: Colors.border,
  },
  filterOptionText: {
    fontSize: fontSize.md,
    color: Colors.text,
    fontFamily: Fonts.PFregular,
  },
  filterOptionSelected: {
    backgroundColor: Colors.primary,
    borderColor: Colors.primary,
  },
  filterOptionTextSelected: {
    color: Colors.white,
  },
  markAllButton: {
    backgroundColor: Colors.primary,
    paddingVertical: hp(1.5),
    paddingHorizontal: wp(4),
    borderRadius: BorderRadius.md,
    marginTop: hp(2),
    alignSelf: 'center',
  },
  markAllButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  footerSpace: {
    height: hp(10),
  },
  methodButton: {
    backgroundColor: Colors.primary,
    paddingVertical: hp(2),
    paddingHorizontal: wp(4),
    borderRadius: BorderRadius.md,
    marginBottom: hp(2),
    alignItems: 'center',
  },
  methodButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  methodButtonIcon: {
    width: wp(5),
    height: wp(5),
    marginLeft: wp(2),
    tintColor: Colors.white,
  },
  exportFormatRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: hp(2),
    marginTop: hp(1),
  },
  exportFormatCard: {
    flex: 1,
    backgroundColor: Colors.accent,
    borderRadius: BorderRadius.md,
    marginHorizontal: wp(1),
    paddingVertical: hp(2),
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'row',
    borderWidth: 1,
    borderColor: Colors.border,
  },
  exportFormatCardActive: {
    backgroundColor: Colors.primary,
    borderColor: Colors.primary,
  },
  exportFormatLabel: {
    color: Colors.text,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
    marginRight: wp(2),
  },
  exportFormatLabelActive: {
    color: Colors.white,
  },
  exportDownloadIconBtn: {
    padding: wp(1.5),
    borderRadius: BorderRadius.sm,
    backgroundColor: Colors.primary,
    marginLeft: wp(1),
  },
  exportDownloadIcon: {
    width: wp(6),
    height: wp(6),
    tintColor: Colors.white,
  },
  exportFormatCardStatic: {
    flex: 1,
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.md,
    marginHorizontal: wp(1),
    paddingVertical: hp(2),
    alignItems: 'center',
    justifyContent: 'space-between',
    flexDirection: 'row',
    borderWidth: 1,
    borderColor: Colors.border,
    marginBottom: hp(1.5),
  },
  exportFormatLabelStatic: {
    color: Colors.text,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
    marginLeft: wp(2),
  },
  exportFormatActions: {
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: wp(2),
  },
  exportShareIconBtn: {
    padding: wp(1.5),
    borderRadius: BorderRadius.sm,
    backgroundColor: Colors.primary,
    marginLeft: wp(1),
  },
  exportShareIcon: {
    width: wp(6),
    height: wp(6),
    tintColor: Colors.white,
  },
  modalActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: hp(3),
    gap: wp(2),
  },
  modalButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: wp(3),
    borderRadius: BorderRadius.md,
    gap: wp(2),
  },
  modalButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  icon: {
    height: 24,
    width: 24,
  },
  iconBlack: {
    tintColor: 'black',
  },
  iconWhite: {
    tintColor: 'white',
  },
  detailsModalContent: {
    backgroundColor: Colors.white,
    borderTopLeftRadius: BorderRadius.lg,
    borderTopRightRadius: BorderRadius.lg,
    padding: wp(5),
    width: wp(100),
    maxHeight: hp(80),
  },
  detailsHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: hp(2),
  },
  detailsTitle: {
    fontSize: fontSize.xl,
    color: Colors.text,
    marginBottom: hp(2.5),
    fontFamily: Fonts.PFbold,
    textAlign: 'center',
  },
  closeButton: {
    position: 'absolute',
    top: hp(2),
    right: wp(4),
    padding: wp(2),
  },
  closeButtonText: {
    fontSize: fontSize.xl,
    color: Colors.text,
    fontFamily: Fonts.PFmedium,
  },
  detailsBody: {
    marginBottom: hp(2),
  },
  detailsActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: hp(2),
  },
  actionButton: {
    flex: 1,
    paddingVertical: hp(1.5),
    borderRadius: BorderRadius.md,
    alignItems: 'center',
    marginHorizontal: wp(2),
  },
  actionButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
});
--- src/screens/admin/Home/Home.tsx ---
import React from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  Image,
  ScrollView,
  SafeAreaView,
  Alert,
  TextInput,
  ActivityIndicator,
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { useAuth } from '../../../context/AuthContext';
import {styles } from './styles.tsx';
import { useData } from '../../../context/DataContext';

const Home = () => {
  const insets = useSafeAreaInsets();
  const { user, logout } = useAuth();
  const {
    latitude,
    longitude,
    setLatitude,
    setLongitude,
    hasExistingLocation,
    isLocationLoading,
    saveLocation,
    handleUpdateLocation,
  } = useData();

  const handleLogout = () => {
    Alert.alert(
      'Logout',
      'Are you sure you want to logout?',
      [
        { text: 'Cancel', style: 'cancel' },
        { text: 'Logout', onPress: logout, style: 'destructive' },
      ]
    );
  };

  const getCurrentDate = () => {
    const options: Intl.DateTimeFormatOptions = {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    };
    return new Date().toLocaleDateString('en-US', options);
  };

  return (
    <SafeAreaView style={[styles.container, { paddingTop: insets.top }]}>
      <View style={styles.header}>
        <View>
          <Text style={styles.greeting}>Welcome,</Text>
          <Text style={styles.name}>{user?.name ?? 'Admin'}</Text>
          <Text style={styles.dateText}>{getCurrentDate()}</Text>
        </View>
        <TouchableOpacity style={styles.avatarContainer}>
          <Image source={require('../../../assets/images/avatar.png')} style={styles.avatar} />
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.scrollContainer} showsVerticalScrollIndicator={false}>
        <View style={styles.locationContainer}>
          <Text style={styles.sectionTitle}>Location Settings</Text>
          
          <View style={styles.inputContainer}>
            <Text style={styles.inputLabel}>Latitude</Text>
            <TextInput
              style={[styles.input, !hasExistingLocation && styles.inputEditable]}
              value={latitude}
              onChangeText={setLatitude}
              placeholder="Enter latitude"
              keyboardType="numeric"
              placeholderTextColor="lightgray"
              editable={!hasExistingLocation}
            />
          </View>

          <View style={styles.inputContainer}>
            <Text style={styles.inputLabel}>Longitude</Text>
            <TextInput
              style={[styles.input, !hasExistingLocation && styles.inputEditable]}
              value={longitude}
              onChangeText={setLongitude}
              placeholder="Enter longitude"
              keyboardType="numeric"
              placeholderTextColor="lightgray"
              editable={!hasExistingLocation}
            />
          </View>

          <View style={styles.buttonContainer}>
            <TouchableOpacity
              style={[styles.button, styles.updateButton]}
              onPress={handleUpdateLocation}
              disabled={isLocationLoading}>
              {isLocationLoading ? (
                <ActivityIndicator color="white" />
              ) : (
                <Text style={styles.buttonText}>
                  {hasExistingLocation ? 'Update Location' : 'Fetch Location'}
                </Text>
              )}
            </TouchableOpacity>

            {!hasExistingLocation && (
              <TouchableOpacity
                style={[styles.button, styles.saveButton]}
                onPress={saveLocation}
                disabled={isLocationLoading}>
                <Text style={styles.buttonText}>Save Location</Text>
              </TouchableOpacity>
            )}
          </View>

          {hasExistingLocation && (
            <Text style={styles.locationInfo}>
              Location is set. You can update it by clicking the Update Location button.
            </Text>
          )}
        </View>

        <View style={styles.footerSpace} />
      </ScrollView>

      <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
        <Image
          source={require('../../../assets/icons/logout.png')}
          style={styles.logoutIcon}
        />
        <Text style={styles.logoutText}>Log Out</Text>
      </TouchableOpacity>
    </SafeAreaView>
  );
};

export default Home;
--- src/screens/admin/Home/styles.tsx ---
// src/screens/admin/attendance/styles.tsx
import { StyleSheet } from 'react-native';
import { Colors, Fonts, Responsive, BorderRadius, Spacing } from '../../../globalStyles';

const { wp, hp, fontSize } = Responsive;

export const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: Colors.background,
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: Spacing.l,
      paddingVertical: Spacing.m,
      backgroundColor: Colors.white,
      borderBottomWidth: 1,
      borderBottomColor: Colors.border,
    },
    greeting: {
      fontSize: fontSize.lg,
      color: Colors.textLight,
      fontFamily: Fonts.PFregular,
    },
    name: {
      fontSize: fontSize.xxl,
      color: Colors.text,
      fontFamily: Fonts.PFbold,
      marginTop: hp(0.5),
    },
    dateText: {
      fontSize: fontSize.sm,
      color: Colors.textLight,
      fontFamily: Fonts.PFregular,
      marginTop: hp(0.5),
    },
    avatarContainer: {
      width: wp(12),
      height: wp(12),
      borderRadius: BorderRadius.round,
      overflow: 'hidden',
      borderWidth: 2,
      borderColor: Colors.primary,
    },
    avatar: {
      width: '100%',
      height: '100%',
      resizeMode: 'cover',
    },
    scrollContainer: {
      flex: 1,
      paddingHorizontal: Spacing.m,
    },
    statsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginTop: Spacing.l,
    },
    statCard: {
      width: '48%',
      backgroundColor: Colors.white,
      borderRadius: BorderRadius.lg,
      padding: Spacing.m,
    },
    iconContainer: {
      width: wp(15),
      height: wp(15),
      borderRadius: BorderRadius.lg,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: Spacing.m,
    },
    icon: {
      fontSize: fontSize.xl,
    },
    statValue: {
      fontSize: fontSize.xxl,
      fontFamily: Fonts.PFbold,
      color: Colors.text,
      marginBottom: hp(0.5),
    },
    statLabel: {
      fontSize: fontSize.md,
      fontFamily: Fonts.PFregular,
      color: Colors.textLight,
    },
    sectionTitleContainer: {
      paddingHorizontal: Spacing.l,
      marginTop: Spacing.m,
      marginBottom: Spacing.s,
    },
    sectionTitle: {
      fontSize: fontSize.lg,
      color: Colors.text,
      fontFamily: Fonts.PFbold,
    },
    actionContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingHorizontal: Spacing.l,
      marginBottom: Spacing.m,
    },
    actionButton: {
      width: wp(26),
      backgroundColor: Colors.white,
      borderRadius: BorderRadius.md,
      padding: Spacing.m,
      alignItems: 'center',
    },
    actionIcon: {
      width: wp(10),
      height: wp(10),
      borderRadius: wp(5),
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: hp(1),
    },
    actionIconText: {
      fontSize: fontSize.xl,
    },
    actionText: {
      fontSize: fontSize.sm,
      color: Colors.text,
      fontFamily: Fonts.PFmedium,
      textAlign: 'center',
    },
    activityContainer: {
      paddingHorizontal: Spacing.l,
      marginBottom: Spacing.m,
    },
    activityItem: {
      flexDirection: 'row',
      backgroundColor: Colors.white,
      borderRadius: BorderRadius.md,
      padding: Spacing.m,
      marginBottom: Spacing.s,
    },
    activityIconContainer: {
      width: wp(10),
      height: wp(10),
      borderRadius: wp(5),
      backgroundColor: Colors.background,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: Spacing.m,
    },
    activityIcon: {
      fontSize: fontSize.lg,
    },
    activityContent: {
      flex: 1,
    },
    activityDescription: {
      fontSize: fontSize.md,
      color: Colors.text,
      fontFamily: Fonts.PFmedium,
      marginBottom: hp(0.5),
    },
    activityTime: {
      fontSize: fontSize.xs,
      color: Colors.textLight,
      fontFamily: Fonts.PFregular,
    },
    loader: {
      marginVertical: Spacing.l,
    },
    footerSpace: {
      height: hp(10),
    },
    logoutButton: {
      position: 'absolute',
      bottom: hp(2.5),
      left: wp(5),
      right: wp(5),
      height: hp(6),
      borderRadius: BorderRadius.lg,
      overflow: 'hidden',
      backgroundColor:Colors.errorLight,
      justifyContent:'center',
      alignItems:'center',
      flexDirection:'row',
    },
    logoutIcon: {
      width: wp(5),
      height: wp(5),
      tintColor: Colors.white,
      marginRight: Spacing.s,
    },
    logoutText: {
      fontSize: fontSize.md,
      fontFamily: Fonts.PFmedium,
      color: Colors.white,
      fontWeight: '600',
    },
    addAttendance: { backgroundColor: Colors.success + '20' },
    addCourses: { backgroundColor: Colors.accent + '20' },
    addStudents: { backgroundColor: Colors.primary + '20' },
    attendance: {
      backgroundColor: Colors.success,
    },
    students: {
      backgroundColor: Colors.primary,
    },
    courses: {
      backgroundColor: Colors.secondary,
    },
    activeStudents: {
      backgroundColor: Colors.accent,
    },
    locationContainer: {
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 16,
    margin: 16,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3,
    elevation: 3,
  },
  inputContainer: {
    marginBottom: 16,
  },
  inputLabel: {
    fontSize: 14,
    color: '#4A5568',
    marginBottom: 8,
  },
  input: {
    borderWidth: 1,
    borderColor: '#E2E8F0',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    color: '#1A202C',
    backgroundColor: '#F7FAFC',
  },
  inputEditable: {
    backgroundColor: 'white',
    borderColor: '#5271FF',
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 12,
  },
  button: {
    flex: 1,
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  updateButton: {
    backgroundColor: '#5271FF',
  },
  saveButton: {
    backgroundColor: '#48BB78',
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  locationInfo: {
    marginTop: 12,
    fontSize: 14,
    color: '#4A5568',
    textAlign: 'center',
    fontStyle: 'italic',
  },
});
--- src/screens/admin/Students/Students.tsx ---
import React, {useState, useMemo, useEffect} from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  Modal,
  TextInput,
  Alert,
  ScrollView,
  SafeAreaView,
  Platform,
  Image,
} from 'react-native';
import * as DocumentPicker from '@react-native-documents/picker';
import RNFS from 'react-native-fs';
import {styles} from './styles';
import {Picker} from '@react-native-picker/picker';
import {useData} from '../../../context/DataContext';
import Share from 'react-native-share';
import RNHTMLtoPDF from 'react-native-html-to-pdf';
import {Colors} from '../../../globalStyles';

interface Student {
  id: string;
  email:string;
  name: string;
  gender: 'Male' | 'Female' | 'Others';
  abcId: number;
  semester: number;
  batch: number;
  year: string;
  status: 'Active' | 'Inactive';
  course: string;
}

interface StudentImport {
  [key: string]: string | null;
}

interface IconMap {
  [key: string]: any;
}

export default function Students() {
  const {
    studentsDataAll,
    fetchStudentsDataAll,
    addStudent,
    updateStudent,
    deleteStudent,
    courseData,
    fetchCourseData,
  } = useData();

  const [modalVisible, setModalVisible] = useState(false);
  const [filterModalVisible, setFilterModalVisible] = useState(false);
  const [detailsModalVisible, setDetailsModalVisible] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [statusFilter, setStatusFilter] = useState<
    'all' | 'Active' | 'Inactive'
  >('all');
  const [batchFilter, setBatchFilter] = useState('');
  const [courseFilter, setCourseFilter] = useState('');

  const [editId, setEditId] = useState<string | null>(null);

  const [studentName, setStudentName] = useState('');
  const [studentEmail, setStudentEmail] = useState('');
  const [gender, setGender] = useState<'Male' | 'Female' | 'Others'>('Male');
  const [abcId, setAbcId] = useState('');
  const [selectedCourse, setSelectedCourse] = useState('');
  const [semester, setSemester] = useState('');
  const [batch, setBatch] = useState('');
  const [year, setYear] = useState('');
  const [status, setStatus] = useState<'Active' | 'Inactive'>('Active');

  const [addMethodModalVisible, setAddMethodModalVisible] = useState(false);

  const [exportModalVisible, setExportModalVisible] = useState(false);
  const [exportFormat, setExportFormat] = useState<'csv' | 'pdf'>('csv');
  const [exportStatusFilter, setExportStatusFilter] = useState<
    'all' | 'Active' | 'Inactive'
  >('all');
  const [exportCourseFilter, setExportCourseFilter] = useState('');
  const [exportBatchFilter, setExportBatchFilter] = useState('');
  const [exportSemesterFilter, setExportSemesterFilter] = useState('');

  const [selectedStudent, setSelectedStudent] = useState<Student | null>(null);

  const currentYear = new Date().getFullYear();
  const batchYears = useMemo(() => {
    return Array.from(
      {length: currentYear + 6 - 1950 + 1},
      (_, i) => currentYear + 6 - i,
    );
  }, []);

  useEffect(() => {
    console.log('📞 Fetching student data in Student.tsx');
    fetchStudentsDataAll();
    // console.log('📞 Fetching course data in Student.tsx');
    fetchCourseData();
  }, []);

  const activeCourses =
    courseData?.filter(course => course.Status === 'Active') || [];
  console.log('Active Courses:', activeCourses);

  const filteredStudents = useMemo(() => {
    if (!Array.isArray(studentsDataAll)) {
      return [];
    }
    return studentsDataAll
      .map(doc => ({
        id: doc.$id,
        name: doc.Name ?? '',
        email: doc.Email,
        gender: doc.Gender,
        abcId: doc.ABC_ID,
        course: doc.Course?.$id ?? '',
        semester: doc.Semester,
        batch: doc.Batch,
        year: doc.Year,
        status: doc.Status,
      }))
      .filter(student => {
        const matchesSearch = student.name
          .toLowerCase()
          .includes(searchTerm.toLowerCase());
        const matchesStatus =
          statusFilter === 'all' || student.status === statusFilter;
        const matchesBatch =
          !batchFilter || student.batch.toString() === batchFilter;
        const matchesCourse = !courseFilter || student.course === courseFilter;
        return matchesSearch && matchesStatus && matchesCourse && matchesBatch;
      });
  }, [studentsDataAll, searchTerm, statusFilter, batchFilter, courseFilter]);

  const resetForm = () => {
    setStudentName('');
    setStudentEmail('');
    setGender('Male');
    setAbcId('');
    setSemester('');
    setBatch('');
    setYear('');
    setStatus('Active');
    setEditId(null);
  };

  const clearFilters = () => {
    setSearchTerm('');
    setStatusFilter('all');
    setBatchFilter('');
    setCourseFilter('');
  };

  const handleSubmit = async () => {
    const abcIdNum = parseInt(abcId, 10);
    const semesterNum = parseInt(semester, 10);
    const batchNum = parseInt(batch, 10);
    const yearStr = year;

    if (
      !studentName ||
      !abcId ||
      !semester ||
      !batch ||
      !year ||
      !selectedCourse
    ) {
      Alert.alert('Missing fields', 'Please fill all required fields.');
      return;
    }

    if (editId) {
      await updateStudent(
        editId,
        studentName,
        studentEmail,
        gender,
        abcIdNum,
        semesterNum,
        batchNum,
        yearStr as any,
        status,
        selectedCourse,
      );
    } else {
      await addStudent(
        studentName,
        studentEmail,
        gender,
        abcIdNum,
        semesterNum,
        batchNum,
        yearStr as any,
        status,
        selectedCourse,
      );
    }

    console.log('🧪 Submitting Student Update:', {
      id: editId,
      name: studentName,
      email: studentEmail,
      gender,
      abcIdNum,
      semesterNum,
      batchNum,
      yearStr,
      status,
    });

    resetForm();
    setModalVisible(false);
  };
  const handleSync = async () => {
    try {
      await syncManualStudents();
      Alert.alert('Success', 'Student synchronization completed.');
    } catch (err) {
      Alert.alert('Error', err.message);
    }
  };

  const handleEdit = (student: Student) => {
    setEditId(student.id);
    setStudentName(student.name);
    setStudentEmail(student.email);
    setGender(student.gender);
    setAbcId(student.abcId?.toString() ?? '');
    setSemester(student.semester?.toString() ?? '');
    setBatch(student.batch?.toString() ?? '');
    setSelectedCourse(student.course ?? '');
    // Only accept valid year enum
    const validYears = ['First', 'Second', 'Third', 'Fourth', 'Fifth'];
    const validYear = validYears.includes(student.year)
      ? student.year
      : 'First';
    setYear(validYear);

    setStatus(student.status);
    setModalVisible(true);
  };

  const handleDelete = (id: string) => {
    Alert.alert(
      'Delete Student',
      'Are you sure you want to delete this student?',
      [
        {text: 'Cancel', style: 'cancel'},
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            await deleteStudent(id);
            resetForm();
          },
        },
      ],
    );
  };

  // iconMap.js or inside the component
  const iconMap: IconMap = {
    csv: require('../../../assets/icons/csv.png'),
    pdf: require('../../../assets/icons/pdf.png'),
  };

  const renderStudentItem = ({item}: {item: Student}) => {
    const course = courseData?.find(c => c.$id === item.course);
    const courseName = course?.Programme || 'Unknown';
    const isCourseInactive = course?.Status === 'Inactive';
    const initials = item.name
      .split(' ')
      .map(word => word[0])
      .join('')
      .toUpperCase();

    const getStatusColor = () => {
      if (isCourseInactive) return Colors.warning;
      return item.status === 'Active' ? Colors.success : Colors.error;
    };

    return (
      <TouchableOpacity
        style={[
          styles.studentItem,
          (item.status === 'Inactive' || isCourseInactive) &&
            styles.disabledItem,
        ]}
        onPress={() => {
          if (!isCourseInactive) {
            setSelectedStudent(item);
            setDetailsModalVisible(true);
          }
        }}
        disabled={isCourseInactive}>
        <View style={styles.studentItemContent}>
          <View style={styles.studentAvatar}>
            <Text style={styles.studentAvatarText}>{initials}</Text>
          </View>
          <View style={styles.studentMainInfo}>
            <View style={{flexDirection: 'row', alignItems: 'center'}}>
              <Text style={styles.studentName}>{item.name}</Text>
              {isCourseInactive && (
                <Text style={[styles.courseStatus, {color: Colors.warning}]}>
                  {' '}
                  (Course Inactive)
                </Text>
              )}
            </View>
            <Text style={styles.studentCourse}>{courseName}</Text>
          </View>
          <View
            style={[
              styles.statusIndicator,
              {backgroundColor: getStatusColor()},
            ]}
          />
        </View>
      </TouchableOpacity>
    );
  };

  console.log('Filtered Students', filteredStudents);

  // File upload handler (logic to be implemented next)
  const handleFileUpload = async () => {
    try {
      const result = await DocumentPicker.pick({
        presentationStyle: 'fullScreen',
        type: [
          'application/json',
          'text/csv',
          'text/comma-separated-values',
          'application/csv',
          '.csv',
          '.json',
        ],
        allowMultiSelection: false,
      });
      const file = result[0];
      if (
        !file.name?.toLowerCase().endsWith('.json') &&
        !file.name?.toLowerCase().endsWith('.csv')
      ) {
        Alert.alert('Error', 'Please select a JSON or CSV file');
        return;
      }
      let fileContent = '';
      if (Platform.OS === 'android') {
        const fileUri = file.uri;
        if (fileUri.startsWith('content://')) {
          const destPath = `${RNFS.TemporaryDirectoryPath}/${file.name}`;
          await RNFS.copyFile(fileUri, destPath);
          fileContent = await RNFS.readFile(destPath);
          await RNFS.unlink(destPath);
        } else {
          fileContent = await RNFS.readFile(fileUri);
        }
      } else if (Platform.OS === 'ios') {
        fileContent = await RNFS.readFile(file.uri);
      } else {
        const response = await fetch(file.uri);
        fileContent = await response.text();
      }

      let students = [];
      if (file.name.toLowerCase().endsWith('.json')) {
        try {
          students = JSON.parse(fileContent);
        } catch (e) {
          Alert.alert('Error', 'Invalid JSON format');
          return;
        }
      } else {
        // Parse CSV
        const lines = fileContent
          .split('\n')
          .filter(line => line.trim() !== '');
        if (lines.length < 2) {
          Alert.alert(
            'Error',
            'CSV file must contain at least a header row and one data row',
          );
          return;
        }
        const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
        const requiredHeaders = [
          'name',
          'email',
          'gender',
          'abc_id',
          'semester',
          'batch',
          'year',
          'status',
          'course',
        ];
        const missingHeaders = requiredHeaders.filter(
          h => !headers.includes(h),
        );
        if (missingHeaders.length > 0) {
          Alert.alert(
            'Error',
            `Missing required headers: ${missingHeaders.join(', ')}`,
          );
          return;
        }
        students = lines.slice(1).map((line, idx) => {
          const values = line.split(',').map(v => v.trim());
          if (values.length < headers.length) {
            throw new Error(`Invalid number of columns in row ${idx + 2}`);
          }
          const student: StudentImport = {};
          headers.forEach((header, i) => {
            student[header] = values[i] === '' ? null : values[i];
          });
          return student;
        });
      }
      if (!Array.isArray(students) || students.length === 0) {
        Alert.alert('Error', 'No valid students found in the file');
        return;
      }
      // Validation and import
      const validGenders = ['Male', 'Female', 'Others'];
      const validStatuses = ['Active', 'Inactive'];
      const validYears = ['First', 'Second', 'Third', 'Fourth', 'Fifth'];
      // Map course names (case-insensitive) to IDs
      const courseNameToId: {[key: string]: string} = {};
      courseData?.forEach((c: any) => {
        courseNameToId[(c.Programme || '').toLowerCase()] = c.$id;
      });
      let added = 0,
        skipped = 0,
        errors = [];
      for (let i = 0; i < students.length; i++) {
        const s: any = students[i];
        // Normalize keys for JSON
        const name = s.name || s.Name;
        const email = s.email || s.Email;
        const gender = s.gender || s.Gender;
        const abc_id = s.abc_id || s.ABC_ID;
        const semester = s.semester || s.Semester;
        const batch = s.batch || s.Batch;
        const year = s.year || s.Year;
        const status = s.status || s.Status;
        let course = (s.course || s.Course) as string;
        const uuid = s.uuid || s.uUID || null;
        // Validate required fields
        if (
          !name ||
          !email ||
          !gender ||
          !abc_id ||
          !semester ||
          !batch ||
          !year ||
          !status ||
          !course
        ) {
          errors.push(`Row ${i + 2}: Missing required fields`);
          skipped++;
          continue;
        }
        // Validate enums
        if (!validGenders.includes(gender)) {
          errors.push(`Row ${i + 2}: Invalid gender: ${gender}`);
          skipped++;
          continue;
        }
        if (!validStatuses.includes(status)) {
          errors.push(`Row ${i + 2}: Invalid status: ${status}`);
          skipped++;
          continue;
        }
        if (!validYears.includes(year)) {
          errors.push(`Row ${i + 2}: Invalid year: ${year}`);
          skipped++;
          continue;
        }
        // Validate numbers
        const abcIdNum = parseInt(abc_id, 10);
        const semesterNum = parseInt(semester, 10);
        const batchNum = parseInt(batch, 10);
        if (isNaN(abcIdNum) || isNaN(semesterNum) || isNaN(batchNum)) {
          errors.push(
            `Row ${i + 2}: Invalid number in abc_id, semester, or batch`,
          );
          skipped++;
          continue;
        }
        // Map course name to ID (case-insensitive)
        const courseId = courseNameToId[course.trim().toLowerCase()];
        if (!courseId) {
          errors.push(
            `Row ${i + 2}: Course name does not exist in DB: ${course}`,
          );
          skipped++;
          continue;
        }
        // Check for duplicates (same name, abc_id, course)
        const isDuplicate = studentsDataAll?.some(
          (stu: any) =>
            (stu.Name === name || stu.name === name) &&
            (stu.ABC_ID == abcIdNum || stu.abcId == abcIdNum) &&
            (stu.Course?.$id === courseId || stu.course === courseId),
        );
        if (isDuplicate) {
          errors.push(
            `Row ${i + 2}: Duplicate student: ${name}, ${abcIdNum}, ${course}`,
          );
          skipped++;
          continue;
        }
        // Add student
        try {
          await addStudent(
            name,
            email,
            gender,
            abcIdNum,
            semesterNum,
            batchNum,
            year,
            status,
            courseId,
          );
          added++;
        } catch (e) {
          errors.push(`Row ${i + 2}: Failed to add student: ${name}`);
          skipped++;
        }
      }
      setAddMethodModalVisible(false);
      fetchStudentsDataAll();
      syncManualStudents();
      Alert.alert(
        'Import Complete',
        `Added: ${added}\nSkipped: ${skipped}\n${
          errors.length ? 'Errors:\n' + errors.join('\n') : ''
        }`,
      );
    } catch (err) {
      const error = err as {code?: string};
      if (error.code !== 'DOCUMENT_PICKER_CANCELED') {
        Alert.alert('Error', 'Failed to read file');
      }
    }
  };

  // Helper to get course name from ID
  function getCourseName(courseId: string) {
    const course = courseData?.find((c: any) => c.$id === courseId);
    return course ? course.Programme : courseId;
  }

  const exportImmediately = async (
    format: 'csv' | 'pdf',
    action: 'download' | 'share',
  ) => {
    try {
      // Filter students based on export filters
      let exportStudents = studentsDataAll || [];
      if (exportStatusFilter !== 'all') {
        exportStudents = exportStudents.filter(
          (doc: any) =>
            (doc.Status || doc.status || '').toLowerCase().trim() ===
            exportStatusFilter.toLowerCase().trim(),
        );
      }
      if (exportCourseFilter) {
        exportStudents = exportStudents.filter(
          (doc: any) =>
            (doc.Course?.$id || doc.course || '').toString().trim() ===
            exportCourseFilter.trim(),
        );
      }
      if (exportBatchFilter) {
        exportStudents = exportStudents.filter(
          (doc: any) =>
            String(doc.Batch || doc.batch || '').trim() ===
            exportBatchFilter.trim(),
        );
      }
      if (exportSemesterFilter) {
        exportStudents = exportStudents.filter(
          (doc: any) =>
            String(doc.Semester || doc.semester || '').trim() ===
            exportSemesterFilter.trim(),
        );
      }
      if (!exportStudents.length) {
        let filterSummary = [];
        if (exportStatusFilter !== 'all') {
          filterSummary.push(`Status: ${exportStatusFilter}`);
        }
        if (exportCourseFilter) {
          filterSummary.push(`Course: ${getCourseName(exportCourseFilter)}`);
        }
        if (exportBatchFilter) {
          filterSummary.push(`Batch: ${exportBatchFilter}`);
        }
        if (exportSemesterFilter) {
          filterSummary.push(`Semester: ${exportSemesterFilter}`);
        }
        const filterMsg = filterSummary.length
          ? `\n\nCurrent filters:\n${filterSummary.join('\n')}`
          : '';
        Alert.alert(
          'No students to export',
          `No students match the selected filters.${filterMsg}\n\nPlease adjust your filters and try again.`,
        );
        setExportModalVisible(false);
        return;
      }
      let fileContent = '';
      let fileName = `students_export_${Date.now()}`;
      let filePath = '';
      let baseDir = '';
      if (Platform.OS === 'android') {
        baseDir = `${RNFS.DownloadDirectoryPath}/Attender/Students`;
      } else {
        baseDir = `${RNFS.DocumentDirectoryPath}/Attender/Students`;
      }
      await RNFS.mkdir(baseDir);
      if (format === 'csv') {
        const headers = [
          'Name',
          'Email',
          'Gender',
          'ABC_ID',
          'Semester',
          'Batch',
          'Year',
          'Status',
          'Course',
        ];
        const rows = (exportStudents as any[]).map(s => [
          s.Name || s.name,
          s.Email || s.email,
          s.Gender || s.gender,
          s.ABC_ID || s.abcId,
          s.Semester || s.semester,
          s.Batch || s.batch,
          s.Year || s.year,
          s.Status || s.status,
          s.Course?.Programme || s.courseName || s.Course || s.course || '',
        ]);
        fileContent = [headers.join(','), ...rows.map(r => r.join(','))].join(
          '\n',
        );
        fileName += '.csv';
        filePath = `${baseDir}/${fileName}`;
        await RNFS.writeFile(String(filePath), fileContent, 'utf8');
      } else if (format === 'pdf') {
        const headers = [
          'Name',
          'Email',
          'Gender',
          'ABC_ID',
          'Semester',
          'Batch',
          'Year',
          'Status',
          'Course',
        ];
        const rowsHtml = (exportStudents as any[])
          .map(
            s =>
              `<tr><td>${s.Name || s.name}</td><td>${s.Email || s.email}</td><td>${
                s.Gender || s.gender
              }</td><td>${s.ABC_ID || s.abcId}</td><td>${
                s.Semester || s.semester
              }</td><td>${s.Batch || s.batch}</td><td>${
                s.Year || s.year
              }</td><td>${s.Status || s.status}</td><td>${
                s.Course?.Programme ||
                s.courseName ||
                s.Course ||
                s.course ||
                ''
              }</td></tr>`,
          )
          .join('');
        const html = `
          <h2>Students Export</h2>
          <table border="1" style="border-collapse:collapse;width:100%">
            <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
            ${rowsHtml}
          </table>
        `;
        fileName += '.pdf';
        // 1. Generate PDF in default location
        const pdf = await RNHTMLtoPDF.convert({
          html,
          fileName: fileName.replace('.pdf', ''),
          base64: false,
        });
        // 2. Move PDF to Downloads/Attender/Students/
        const targetPath = `${baseDir}/${fileName}`;
        await RNFS.mkdir(baseDir);
        await RNFS.moveFile(String(pdf.filePath), String(targetPath));
        filePath = String(targetPath);
      }
      if (action === 'download') {
        Alert.alert('Export Complete', `File saved to:\n${filePath}`);
      } else if (action === 'share') {
        await Share.open({
          url: Platform.OS === 'android' ? `file://${filePath}` : filePath,
          type: format === 'pdf' ? 'application/pdf' : 'text/csv',
          failOnCancel: false,
        });
      }
    } catch (e) {
      Alert.alert(
        'Export Error',
        e instanceof Error ? e.message : 'Failed to export',
      );
    } finally {
      setExportModalVisible(false);
    }
  };

  const renderDetailsModal = () => {
    if (!selectedStudent) {
      return null;
    }
    const course = courseData?.find(c => c.$id === selectedStudent.course);
    const courseName = course?.Programme || 'Unknown';
    const isCourseInactive = course?.Status === 'Inactive';

    return (
      <Modal
        visible={detailsModalVisible}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setDetailsModalVisible(false)}>
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <View style={styles.modalHandle} />
            <Text style={styles.modalTitle}>Student Details</Text>
            <TouchableOpacity
              onPress={() => setDetailsModalVisible(false)}
              style={styles.closeButton}>
              <Text style={styles.closeButtonText}>×</Text>
            </TouchableOpacity>

            <ScrollView showsVerticalScrollIndicator={false}>
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Name:</Text>
                <Text style={styles.detailValue}>{selectedStudent.name}</Text>
              </View>
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Email:</Text>
                <Text style={styles.detailValue}>{selectedStudent.email}</Text>
              </View>
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Course:</Text>
                <Text style={styles.detailValue}>
                  {courseName}
                  {isCourseInactive && (
                    <Text style={{color: Colors.warning}}> (Inactive)</Text>
                  )}
                </Text>
              </View>
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Gender:</Text>
                <Text style={styles.detailValue}>{selectedStudent.gender}</Text>
              </View>
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>ABC ID:</Text>
                <Text style={styles.detailValue}>{selectedStudent.abcId}</Text>
              </View>
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Semester:</Text>
                <Text style={styles.detailValue}>
                  {selectedStudent.semester}
                </Text>
              </View>
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Batch:</Text>
                <Text style={styles.detailValue}>{selectedStudent.batch}</Text>
              </View>
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Year:</Text>
                <Text style={styles.detailValue}>{selectedStudent.year}</Text>
              </View>
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Status:</Text>
                <Text
                  style={[
                    styles.detailValue,
                    {
                      color: isCourseInactive
                        ? Colors.warning
                        : selectedStudent.status === 'Active'
                        ? Colors.success
                        : Colors.error,
                    },
                  ]}>
                  {isCourseInactive
                    ? 'Inactive (Course Inactive)'
                    : selectedStudent.status}
                </Text>
              </View>
            </ScrollView>

            <View style={styles.modalActions}>
              <TouchableOpacity
                style={[
                  styles.modalButton,
                  {
                    backgroundColor: isCourseInactive
                      ? Colors.disabled
                      : Colors.primary,
                  },
                ]}
                onPress={() => {
                  if (!isCourseInactive) {
                    setDetailsModalVisible(false);
                    handleEdit(selectedStudent);
                  }
                }}
                disabled={isCourseInactive}>
                <Image
                  source={require('../../../assets/icons/edit.png')}
                  style={[styles.icon, styles.iconWhite]}
                />
                <Text style={[styles.modalButtonText, {color: Colors.white}]}>
                  {isCourseInactive ? 'Edit Disabled' : 'Edit'}
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.modalButton, {backgroundColor: Colors.error}]}
                onPress={() => {
                  setDetailsModalVisible(false);
                  handleDelete(selectedStudent.id);
                }}>
                <Image
                  source={require('../../../assets/icons/delete.png')}
                  style={[styles.icon, styles.iconWhite]}
                />
                <Text style={[styles.modalButtonText, {color: Colors.white}]}>
                  Delete
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.searchContainer}>
        <Image
          source={require('../../../assets/icons/search.png')}
          style={[styles.icon, styles.iconBlack]}
        />
        <TextInput
          style={styles.searchInput}
          placeholder="Search by name or ID..."
          placeholderTextColor="#A0AEC0"
          value={searchTerm}
          onChangeText={setSearchTerm}
        />
        <TouchableOpacity
          style={styles.filterButton}
          onPress={() => setFilterModalVisible(true)}>
          <Image
            source={require('../../../assets/icons/filter.png')}
            style={[styles.icon, styles.iconWhite]}
          />
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.filterButton, {backgroundColor: Colors.success}]}
          onPress={() => setExportModalVisible(true)}>
          <Image
            source={require('../../../assets/icons/export.png')}
            style={[styles.icon, styles.iconWhite]}
          />
        </TouchableOpacity>
      </View>
      {filteredStudents.length === 0 ? (
        <View style={styles.emptyContainer}>
          <Image
            source={require('../../../assets/icons/share.png')}
            style={[styles.icon, styles.iconWhite]}
          />
          <Text style={styles.emptyText}>No students found</Text>
          <TouchableOpacity
            style={styles.addButton}
            onPress={() => {
              resetForm();
              setModalVisible(true);
            }}>
            <Text style={styles.addButtonText}>Add New Student</Text>
          </TouchableOpacity>
        </View>
      ) : (
        <FlatList
          data={filteredStudents}
          showsVerticalScrollIndicator={false}
          renderItem={renderStudentItem}
          keyExtractor={item => item.id}
          contentContainerStyle={styles.listContent}
          ListFooterComponent={<View style={{height: 100}} />}
        />
      )}
      {renderDetailsModal()}

      <TouchableOpacity
        style={styles.floatingAddButton}
        onPress={() => setAddMethodModalVisible(true)}>
        <Image
          source={require('../../../assets/icons/add.png')}
          style={[styles.icon, styles.iconWhite]}
        />
      </TouchableOpacity>

      {/* Add Method Selection Modal */}
      <Modal
        visible={addMethodModalVisible}
        animationType="fade"
        transparent={true}
        onRequestClose={() => setAddMethodModalVisible(false)}>
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Add Student</Text>
            <TouchableOpacity
              style={styles.methodButton}
              onPress={() => {
                setAddMethodModalVisible(false);
                resetForm();
                setModalVisible(true);
              }}>
              <Text style={styles.methodButtonText}>Add Manually</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.methodButton}
              onPress={handleFileUpload}>
              <Text style={styles.methodButtonText}>Upload CSV/JSON File</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.cancelButtonExport}
              onPress={() => setAddMethodModalVisible(false)}>
              <Text style={styles.cancelButtonText}>Cancel</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Add/Edit Modal */}
      <Modal
        visible={modalVisible}
        animationType="slide"
        transparent
        onRequestClose={() => setModalVisible(false)}>
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>
              {editId ? 'Edit Student' : 'Add New Student'}
            </Text>
            <ScrollView showsVerticalScrollIndicator={false}>
              <TextInput
                style={styles.input}
                placeholder="Student Name"
                value={studentName}
                onChangeText={setStudentName}
                placeholderTextColor={Colors.gray}
              />
              <TextInput
                style={styles.input}
                placeholder="Email"
                value={studentEmail}
                onChangeText={setStudentEmail}
                placeholderTextColor={Colors.gray}
                keyboardType="email-address"
              />
              <TextInput
                style={styles.input}
                placeholder="ABC ID"
                value={abcId}
                onChangeText={setAbcId}
                keyboardType="numeric"
                placeholderTextColor={Colors.gray}
              />
              <View style={styles.input}>
                <Picker
                  selectedValue={gender}
                  onValueChange={value => setGender(value)}
                  style={{color: Colors.text}}>
                  <Picker.Item label="Male" value="Male" />
                  <Picker.Item label="Female" value="Female" />
                  <Picker.Item label="Others" value="Others" />
                </Picker>
              </View>
              <View style={styles.input}>
                <Picker
                  selectedValue={selectedCourse}
                  onValueChange={value => setSelectedCourse(value)}
                  style={{color: Colors.text}}>
                  <Picker.Item label="Select Course" value="" />
                  {activeCourses.map(course => (
                    <Picker.Item
                      key={course.$id}
                      label={course.Programme}
                      value={course.$id}
                    />
                  ))}
                </Picker>
              </View>
              <TextInput
                style={styles.input}
                placeholder="Semester"
                value={semester}
                onChangeText={setSemester}
                keyboardType="numeric"
                placeholderTextColor={Colors.gray}
              />
              <TextInput
                style={styles.input}
                placeholder="Batch"
                value={batch}
                onChangeText={setBatch}
                keyboardType="numeric"
                placeholderTextColor={Colors.gray}
              />
              <View style={styles.input}>
                <Picker
                  selectedValue={year}
                  onValueChange={value => setYear(value)}
                  style={{color: Colors.text}}>
                  <Picker.Item label="First Year" value="First" />
                  <Picker.Item label="Second Year" value="Second" />
                  <Picker.Item label="Third Year" value="Third" />
                  <Picker.Item label="Fourth Year" value="Fourth" />
                  <Picker.Item label="Fifth Year" value="Fifth" />
                </Picker>
              </View>
              <View style={styles.input}>
                <Picker
                  selectedValue={status}
                  onValueChange={value => setStatus(value)}
                  style={{color: Colors.text}}>
                  <Picker.Item label="Active" value="Active" />
                  <Picker.Item label="Inactive" value="Inactive" />
                </Picker>
              </View>
              <View style={styles.modalButtons}>
                <TouchableOpacity
                  style={styles.cancelButton}
                  onPress={() => {
                    setModalVisible(false);
                    resetForm();
                  }}>
                  <Text style={styles.cancelButtonText}>Cancel</Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={styles.saveButton}
                  onPress={handleSubmit}>
                  <Text style={styles.saveButtonText}>Save</Text>
                </TouchableOpacity>
              </View>
            </ScrollView>
          </View>
        </View>
      </Modal>

      {/* Filter Modal */}
      <Modal
        visible={filterModalVisible}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setFilterModalVisible(false)}>
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Filter Students</Text>
            <View style={styles.input}>
              <Picker
                selectedValue={statusFilter}
                onValueChange={value => setStatusFilter(value)}
                style={{color: Colors.text}}>
                <Picker.Item label="All Status" value="all" />
                <Picker.Item label="Active" value="Active" />
                <Picker.Item label="Inactive" value="Inactive" />
              </Picker>
            </View>
            <View style={styles.input}>
              <Picker
                selectedValue={courseFilter}
                onValueChange={value => setCourseFilter(value)}
                style={{color: Colors.text}}>
                <Picker.Item label="All Courses" value="" />
                {activeCourses.map(course => (
                  <Picker.Item
                    key={course.$id}
                    label={course.Programme}
                    value={course.$id}
                  />
                ))}
              </Picker>
            </View>
            <View style={styles.input}>
              <Picker
                selectedValue={batchFilter}
                onValueChange={value => setBatchFilter(value)}
                style={{color: Colors.text}}>
                <Picker.Item label="All Batches" value="" />
                {batchYears.map(year => (
                  <Picker.Item
                    key={year}
                    label={year.toString()}
                    value={year.toString()}
                  />
                ))}
              </Picker>
            </View>
            <View style={styles.modalButtons}>
              <TouchableOpacity
                style={styles.cancelButton}
                onPress={() => {
                  setFilterModalVisible(false);
                  clearFilters();
                }}>
                <Text style={styles.cancelButtonText}>Clear Filters</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={styles.saveButton}
                onPress={() => setFilterModalVisible(false)}>
                <Text style={styles.saveButtonText}>Apply</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Export Modal */}
      <Modal
        visible={exportModalVisible}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setExportModalVisible(false)}>
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Export Students</Text>
            <ScrollView showsVerticalScrollIndicator={false}>
              <Text style={styles.filterSectionTitle}>Filter by Status</Text>
              <View style={styles.input}>
                <Picker
                  selectedValue={exportStatusFilter}
                  onValueChange={value => setExportStatusFilter(value)}
                  style={{color: Colors.text}}>
                  <Picker.Item label="All Students" value="all" />
                  <Picker.Item label="Active" value="Active" />
                  <Picker.Item label="Inactive" value="Inactive" />
                </Picker>
              </View>

              <Text style={styles.filterSectionTitle}>Filter by Course</Text>
              <View style={styles.input}>
                <Picker
                  selectedValue={exportCourseFilter}
                  onValueChange={value => setExportCourseFilter(value)}
                  style={{color: Colors.text}}>
                  <Picker.Item label="All Courses" value="" />
                  {activeCourses.map(course => (
                    <Picker.Item
                      key={course.$id}
                      label={course.Programme}
                      value={course.$id}
                    />
                  ))}
                </Picker>
              </View>

              <Text style={styles.filterSectionTitle}>Filter by Batch</Text>
              <View style={styles.input}>
                <Picker
                  selectedValue={exportBatchFilter}
                  onValueChange={value => setExportBatchFilter(value)}
                  style={{color: Colors.text}}>
                  <Picker.Item label="All Batches" value="" />
                  {batchYears.map(year => (
                    <Picker.Item
                      key={year}
                      label={year.toString()}
                      value={year.toString()}
                    />
                  ))}
                </Picker>
              </View>

              <Text style={styles.filterSectionTitle}>Filter by Semester</Text>
              <View style={styles.input}>
                <Picker
                  selectedValue={exportSemesterFilter}
                  onValueChange={value => setExportSemesterFilter(value)}
                  style={{color: Colors.text}}>
                  <Picker.Item label="All Semesters" value="" />
                  {[1, 2, 3, 4, 5, 6, 7, 8].map(sem => (
                    <Picker.Item
                      key={sem}
                      label={sem.toString()}
                      value={sem.toString()}
                    />
                  ))}
                </Picker>
              </View>

              <Text style={styles.filterSectionTitle}>Export Format</Text>
              <View style={styles.exportFormatRow}>
                {[
                  {type: 'csv', label: 'CSV', icon: 'csv'},
                  {type: 'pdf', label: 'PDF', icon: 'pdf'},
                ].map(fmt => (
                  <View key={fmt.type} style={styles.exportFormatCard}>
                    {/* <Icon name={fmt.icon} size={32} color={Colors.primary} /> */}
                    {/* <Text style={styles.exportFormatLabel}>{fmt.label}</Text> */}
                    <View style={styles.exportFormatActions}>
                      <TouchableOpacity
                        style={styles.exportActionButton}
                        onPress={() =>
                          exportImmediately(
                            fmt.type as 'csv' | 'pdf',
                            'download',
                          )
                        }>
                        <Image
                          source={iconMap[fmt.icon]}
                          style={[styles.icon, styles.iconWhite]}
                        />
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={styles.exportActionButton}
                        onPress={() =>
                          exportImmediately(fmt.type as 'csv' | 'pdf', 'share')
                        }>
                        <Image
                          source={require('../../../assets/icons/share.png')}
                          style={[styles.icon, styles.iconWhite]}
                        />
                      </TouchableOpacity>
                    </View>
                  </View>
                ))}
              </View>
            </ScrollView>
            <View style={styles.modalButtons}>
              <TouchableOpacity
                style={styles.cancelButton}
                onPress={() => setExportModalVisible(false)}>
                <Text style={styles.cancelButtonText}>Cancel</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
}
--- src/screens/admin/Students/styles.tsx ---
import {StyleSheet} from 'react-native';
import {Colors, Fonts, Responsive, BorderRadius} from '../../../globalStyles';

const {wp, hp, fontSize} = Responsive;

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.background,
  },
  pageTitle: {
    fontSize: fontSize.xl,
    fontFamily: Fonts.PFbold,
    color: Colors.text,
    marginHorizontal: wp(4),
    marginTop: hp(2),
    marginBottom: hp(1),
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.round,
    padding: wp(1),
    paddingHorizontal: wp(3),
    margin: wp(4),
    marginTop: hp(3),
    borderWidth: 1,
    borderColor: Colors.border,
  },
  searchInput: {
    flex: 1,
    padding: wp(2.5),
    fontSize: fontSize.md,
    color: Colors.text,
    fontFamily: Fonts.PFregular,
    backgroundColor: 'transparent',
  },
  filterButton: {
    width: wp(10),
    height: wp(10),
    borderRadius: wp(6),
    backgroundColor: Colors.primary,
    justifyContent: 'center',
    alignItems: 'center',
    margin: wp(1),
  },
  filterIcon: {
    fontSize: fontSize.lg,
    color: Colors.white,
  },
  courseStatus: {
    fontSize: 12,
    marginLeft: 4,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: wp(4),
  },
  emptyText: {
    fontSize: fontSize.md,
    color: Colors.textLight,
    marginBottom: hp(2.5),
    fontFamily: Fonts.PFmedium,
    textAlign: 'center',
  },
  addButton: {
    backgroundColor: Colors.primary,
    paddingVertical: hp(1.5),
    paddingHorizontal: wp(6),
    borderRadius: BorderRadius.md,
    marginTop: hp(2),
  },
  addButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  floatingAddButton: {
    position: 'absolute',
    bottom: hp(4),
    right: wp(5),
    width: wp(15),
    height: wp(15),
    backgroundColor: Colors.primary,
    borderRadius: wp(7.5),
    justifyContent: 'center',
    alignItems: 'center',
  },
  floatingAddButtonText: {
    color: Colors.white,
    fontSize: fontSize.xxl,
    fontFamily: Fonts.PFbold,
  },
  listContent: {
    // padding: wp(0),
    paddingHorizontal: wp(4),
  },
  studentItem: {
    flexDirection: 'row',
    backgroundColor: Colors.white,
    padding: wp(3),
    borderRadius: BorderRadius.lg,
    marginBottom: hp(1),
    borderWidth: 1,
    borderColor: Colors.border,
  },
  studentItemContent: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
  },
  studentAvatar: {
    width: wp(12),
    height: wp(12),
    borderRadius: wp(6),
    backgroundColor: '#8AEC7F',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: wp(3),
  },
  studentAvatarText: {
    fontSize: fontSize.lg,
    color: Colors.primary,
    fontFamily: Fonts.PFbold,
  },
  studentMainInfo: {
    flex: 1,
  },
  studentName: {
    fontSize: fontSize.lg,
    color: Colors.text,
    fontFamily: Fonts.PFbold,
    marginBottom: hp(0.5),
  },
  studentCourse: {
    fontSize: fontSize.sm,
    color: Colors.textLight,
    fontFamily: Fonts.PFregular,
  },
  studentGender: {
    fontSize: fontSize.sm,
    color: Colors.textLight,
    fontFamily: Fonts.PFregular,
  },
  swipeAction: {
    justifyContent: 'center',
    alignItems: 'center',
    width: wp(20),
    height: '100%',
  },
  swipeEdit: {
    backgroundColor: Colors.primary,
  },
  swipeDelete: {
    backgroundColor: Colors.error,
  },
  swipeActionText: {
    color: Colors.white,
    fontSize: fontSize.sm,
    fontFamily: Fonts.PFmedium,
  },
  statusIndicator: {
    width: wp(3),
    height: wp(3),
    borderRadius: wp(1.5),
    marginRight: wp(2),
  },
  statusActive: {
    backgroundColor: Colors.success,
  },
  statusInactive: {
    backgroundColor: Colors.error,
  },
  disabledItem: {
    opacity: 0.8,
    borderColor: Colors.error,
  },
  avatar: {
    width: wp(10),
    height: wp(10),
    borderRadius: wp(5),
    backgroundColor: Colors.background,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: wp(4),
  },
  avatarText: {
    fontSize: fontSize.lg,
    color: Colors.text,
    fontFamily: Fonts.PFbold,
  },
  studentDetails: {
    flex: 1,
  },
  studentNameContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: hp(1),
  },
  statusDot: {
    width: wp(3),
    height: wp(3),
    borderRadius: wp(1.5),
    marginRight: wp(2),
  },
  statusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.background,
    paddingHorizontal: wp(3),
    paddingVertical: hp(0.5),
    borderRadius: BorderRadius.md,
  },
  studentInfo: {
    fontSize: fontSize.sm,
    color: Colors.textLight,
    fontFamily: Fonts.PFregular,
    marginBottom: hp(0.5),
  },
  actionButtons: {
    flexDirection: 'row',
    alignItems: 'center',
    marginLeft: wp(2),
  },
  editButton: {
    padding: wp(2),
    marginRight: wp(2),
    backgroundColor: Colors.background,
    borderRadius: BorderRadius.md,
  },
  deleteButton: {
    padding: wp(2),
    backgroundColor: Colors.error + '15',
    borderRadius: BorderRadius.md,
  },
  editIcon: {
    fontSize: fontSize.lg,
    color: Colors.primary,
  },
  deleteIcon: {
    fontSize: fontSize.lg,
    color: Colors.error,
  },
  modalOverlay: {
    flex: 1,
    justifyContent: 'flex-end',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.64)',
  },
  modalContent: {
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.xl,
    borderTopRightRadius: BorderRadius.xl,
    padding: wp(5),
    width: wp(90),
    maxHeight: hp(80),
    bottom: hp(3),
  },
  modalHandle: {
    width: wp(10),
    height: wp(1),
    backgroundColor: Colors.border,
    borderRadius: wp(0.5),
    alignSelf: 'center',
    marginBottom: hp(2),
  },
  modalTitle: {
    fontSize: fontSize.xl,
    color: Colors.text,
    marginBottom: hp(2.5),
    fontFamily: Fonts.PFbold,
    textAlign: 'center',
  },
  closeButton: {
    padding: wp(2),
    position: 'absolute',
    right: wp(4),
    top: hp(4),
  },
  closeButtonText: {
    fontSize: fontSize.xxl,
    color: Colors.textLight,
    fontFamily: Fonts.PFregular,
  },
  input: {
    borderWidth: 1,
    borderColor: Colors.border,
    borderRadius: BorderRadius.md,
    padding: wp(3),
    marginBottom: hp(2),
    fontSize: fontSize.md,
    color: Colors.text,
    fontFamily: Fonts.PFregular,
    backgroundColor: Colors.white,
  },
  filterLabel: {
    fontSize: fontSize.md,
    color: Colors.text,
    marginBottom: hp(1),
    fontFamily: Fonts.PFmedium,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: hp(2),
  },
  cancelButton: {
    backgroundColor: Colors.white,
    borderWidth: 1,
    borderColor: Colors.border,
    paddingVertical: hp(1.5),
    paddingHorizontal: wp(5),
    borderRadius: BorderRadius.md,
    flex: 1,
    marginRight: wp(2),
    alignItems: 'center',
  },
  cancelButtonExport: {
    borderRadius: BorderRadius.md,
    backgroundColor: Colors.background,
    borderWidth: 1,
    borderColor: Colors.border,
    paddingVertical: hp(2),
    paddingHorizontal: wp(4),
    marginBottom: hp(2),
    alignItems: 'center',
  },
  cancelButtonText: {
    color: Colors.text,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  deleteButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  saveButton: {
    backgroundColor: Colors.primary,
    paddingVertical: hp(1.5),
    paddingHorizontal: wp(5),
    borderRadius: BorderRadius.md,
    flex: 1,
    alignItems: 'center',
  },
  icon: {
    height: 24,
    width: 24,
  },
  iconBlack: {
    tintColor: 'black',
  },
  iconWhite: {
    tintColor: 'white',
  },
  saveButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  submitButton: {
    backgroundColor: Colors.primary,
    paddingVertical: hp(1.5),
    paddingHorizontal: wp(5),
    borderRadius: BorderRadius.md,
    flex: 1,
    alignItems: 'center',
  },
  submitButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  clearButton: {
    backgroundColor: Colors.error,
    paddingVertical: hp(1.5),
    paddingHorizontal: wp(5),
    borderRadius: BorderRadius.md,
    flex: 1,
    marginRight: wp(2),
    alignItems: 'center',
  },
  clearButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  statusOptions: {
    flexDirection: 'row',
    marginBottom: hp(2),
  },
  statusOption: {
    flex: 1,
    paddingVertical: hp(1.5),
    alignItems: 'center',
    backgroundColor: Colors.white,
    borderWidth: 0.8,
    marginRight: wp(2),
    borderRadius: BorderRadius.md,
  },
  statusOptionSelected: {
    backgroundColor: Colors.primary,
  },
  statusOptionText: {
    fontSize: fontSize.md,
    color: Colors.textLight,
    fontFamily: Fonts.PFmedium,
  },
  statusOptionTextSelected: {
    color: Colors.white,
  },
  filterSection: {
    marginBottom: hp(2),
  },
  sectionTitle: {
    fontSize: fontSize.lg,
    color: Colors.text,
    fontFamily: Fonts.PFbold,
    marginBottom: hp(1),
  },
  statContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginVertical: hp(2),
    marginHorizontal: wp(4),
  },
  statCard: {
    flex: 1,
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.md,
    padding: wp(4),
    marginHorizontal: wp(1),
    alignItems: 'center',
  },
  statValue: {
    fontSize: fontSize.xl,
    color: Colors.text,
    fontFamily: Fonts.PFbold,
  },
  statLabel: {
    fontSize: fontSize.sm,
    color: Colors.textLight,
    fontFamily: Fonts.PFmedium,
    marginTop: hp(0.5),
  },
  emptyIllustration: {
    width: wp(40),
    height: wp(40),
    marginBottom: hp(2),
  },
  methodButton: {
    backgroundColor: Colors.primary,
    paddingVertical: hp(2),
    paddingHorizontal: wp(4),
    borderRadius: BorderRadius.md,
    marginBottom: hp(2),
    alignItems: 'center',
  },
  methodButtonText: {
    color: Colors.white,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  filterSectionTitle: {
    fontSize: fontSize.md,
    fontFamily: Fonts.PFbold,
    color: Colors.text,
    marginBottom: hp(1),
    marginTop: hp(2),
  },
  filterOption: {
    padding: wp(3),
    borderRadius: BorderRadius.md,
    backgroundColor: Colors.white,
    marginBottom: hp(1.25),
    borderWidth: 1,
    borderColor: Colors.border,
  },
  filterOptionSelected: {
    backgroundColor: Colors.primary,
    borderColor: Colors.primary,
  },
  filterOptionText: {
    fontSize: fontSize.md,
    color: Colors.text,
    fontFamily: Fonts.PFregular,
  },
  filterOptionTextSelected: {
    color: Colors.white,
  },
  exportFormatRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: hp(2),
    marginTop: hp(1),
  },
  exportFormatCard: {
    flex: 1,
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.lg,
    marginHorizontal: wp(1),
    padding: wp(4),
    alignItems: 'center',
    borderWidth: 1,
    borderColor: Colors.border,
  },
  exportFormatLabel: {
    color: Colors.text,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
    marginTop: hp(1),
    marginBottom: hp(1),
  },
  exportFormatActions: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    width: '100%',
  },
  exportActionButton: {
    padding: wp(2),
    borderRadius: BorderRadius.md,
    backgroundColor: Colors.primary,
    marginHorizontal: wp(1),
  },
  bottomSheet: {
    backgroundColor: Colors.white,
    borderTopLeftRadius: BorderRadius.xl,
    borderTopRightRadius: BorderRadius.xl,
    padding: wp(5),
  },
  bottomSheetHandle: {
    width: wp(10),
    height: wp(1),
    backgroundColor: Colors.border,
    borderRadius: wp(0.5),
    alignSelf: 'center',
    marginBottom: hp(2),
  },
  bottomSheetTitle: {
    fontSize: fontSize.xl,
    color: Colors.text,
    fontFamily: Fonts.PFbold,
    marginBottom: hp(2),
  },
  detailRow: {
    flexDirection: 'row',
    marginBottom: hp(1.5),
    paddingVertical: hp(0.5),
  },
  detailLabel: {
    width: wp(30),
    fontSize: fontSize.md,
    color: Colors.textLight,
    fontFamily: Fonts.PFmedium,
  },
  detailValue: {
    flex: 1,
    fontSize: fontSize.md,
    color: Colors.text,
    fontFamily: Fonts.PFregular,
  },
  bottomSheetActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: hp(3),
    paddingTop: hp(2),
    borderTopWidth: 1,
    borderTopColor: Colors.border,
  },
  bottomSheetButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: hp(1.5),
    borderRadius: BorderRadius.md,
    marginHorizontal: wp(1),
  },
  bottomSheetButtonText: {
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
    marginLeft: wp(2),
  },
  modalActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: hp(3),
    paddingTop: hp(2),
    borderTopWidth: 1,
    borderTopColor: Colors.border,
  },
  modalButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: hp(1.5),
    borderRadius: BorderRadius.md,
    marginHorizontal: wp(1),
  },
  modalButtonText: {
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
    marginLeft: wp(2),
  },
});
--- src/screens/Login/LoginScreen.tsx ---
import React, {useEffect, useRef, useState} from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  Image,
  KeyboardAvoidingView,
  Platform,
  Pressable,
  StatusBar,
  Animated,
  ActivityIndicator,
  ToastAndroid,
  // NativeModules,
  // Alert,
  // BackHandler,
  // Linking,
} from 'react-native';
import {useSafeAreaInsets} from 'react-native-safe-area-context';
import LinearGradient from 'react-native-linear-gradient';
import {Colors} from '../../globalStyles';
import styles from './styles';
import {useAuth} from '../../context/AuthContext';

// const { DevSettingsCheck } = NativeModules;

const LoginScreen = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [devBlocked, setDevBlocked] = useState(false);

  const insets = useSafeAreaInsets();
  const floatingLabelAnimEmail = useRef(new Animated.Value(0)).current;
  const floatingLabelAnimPassword = useRef(new Animated.Value(0)).current;
  const {login, authError} = useAuth();

  const animateLabel = (animValue: Animated.Value, isActive: boolean) => {
    Animated.timing(animValue, {
      toValue: isActive ? 1 : 0,
      duration: 200,
      useNativeDriver: false,
    }).start();
  };

  const floatingLabelStyle = (animValue: Animated.Value) => ({
    top: animValue.interpolate({
      inputRange: [0, 1],
      outputRange: [20, 5],
    }),
    fontSize: animValue.interpolate({
      inputRange: [0, 1],
      outputRange: [16, 12],
    }),
    color: animValue.interpolate({
      inputRange: [0, 1],
      outputRange: [Colors.textLight, Colors.primary],
    }),
  });

  const handleLogin = async () => {
    setLoading(true);
    try {
      await login(email, password);
    } catch (err) {
      if (err instanceof Error) {
        console.error('Login failed:', err.message);
      } else {
        console.error('Login failed:', err);
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (authError) {
      ToastAndroid.show(authError, ToastAndroid.LONG);
    }
  }, [authError]);

  // const checkDevMode = async () => {
  //   try {
  //     const isDev = await DevSettingsCheck.isDeveloperModeEnabled();
  //     return isDev;
  //   } catch (error) {
  //     console.error('Error checking dev mode:', error);
  //     return false;
  //   }
  // };

  // useEffect(() => {
  //   const check = async () => {
  //     const isDev = await checkDevMode();
  //     if (isDev) {
  //       setDevBlocked(true); // block UI rendering

  //       Alert.alert(
  //         'Security Warning',
  //         'Developer Options are enabled. Please disable them to continue using the app.',
  //         [
  //           {
  //             text: 'Open Settings',
  //             onPress: () => {
  //               Linking.openSettings(); // Opens device settings
  //             },
  //           },
  //           {
  //             text: 'Exit App',
  //             onPress: () => BackHandler.exitApp(),
  //             style: 'destructive',
  //           },
  //         ],
  //         { cancelable: false }
  //       );
  //     }
  //   };
  //   check();
  // }, []);
  // if (devBlocked) {
  //   return (
  //     <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#fff' }}>
  //       <Text style={{ fontSize: 16, color: 'red', textAlign: 'center', paddingHorizontal: 20 }}>
  //         This app is disabled while Developer Options are enabled.
  //       </Text>
  //     </View>
  //   );
  // }

  return (
    <KeyboardAvoidingView
      style={[
        styles.container,
        {paddingTop: insets.top, paddingBottom: insets.bottom},
      ]}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}>
      <StatusBar barStyle="dark-content" backgroundColor={Colors.background} />

      <View style={styles.header}>
        <Image
          source={require('../../assets/images/logo.png')}
          style={styles.logo}
        />
        <Text style={styles.title}>Attender</Text>
        <Text style={styles.subtitle}>Enter your credentials to continue</Text>
      </View>

      <View style={styles.card}>
        <View style={styles.inputContainer}>
          <Animated.Text
            style={[
              styles.floatingLabel,
              floatingLabelStyle(floatingLabelAnimEmail),
            ]}>
            Email Address
          </Animated.Text>
          <TextInput
            style={styles.input}
            value={email}
            onChangeText={setEmail}
            onFocus={() => animateLabel(floatingLabelAnimEmail, true)}
            onBlur={() =>
              email.length === 0 && animateLabel(floatingLabelAnimEmail, false)
            }
            keyboardType="email-address"
            autoCapitalize="none"
            placeholderTextColor={Colors.textLight}
          />
        </View>

        <View style={styles.inputContainer}>
          <Animated.Text
            style={[
              styles.floatingLabel,
              floatingLabelStyle(floatingLabelAnimPassword),
            ]}>
            Password
          </Animated.Text>
          <TextInput
            style={styles.input}
            secureTextEntry={!showPassword}
            value={password}
            onChangeText={setPassword}
            onFocus={() => animateLabel(floatingLabelAnimPassword, true)}
            onBlur={() =>
              password.length === 0 &&
              animateLabel(floatingLabelAnimPassword, false)
            }
            placeholderTextColor={Colors.textLight}
          />
          <Pressable onPress={() => setShowPassword(!showPassword)}>
            <Image
              source={
                showPassword
                  ? require('../../assets/icons/eye.png')
                  : require('../../assets/icons/eyeoff.png')
              }
              style={styles.icon}
            />
          </Pressable>
        </View>

        {authError && <Text style={styles.authError}>{authError}</Text>}

        <TouchableOpacity style={styles.forgotPasswordContainer}>
          <Text style={styles.forgotPasswordText}>Forgot Password?</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[
            styles.button,
            (!email || !password) && styles.buttonDisabled,
          ]}
          onPress={handleLogin}
          disabled={!email || !password}>
          <LinearGradient
            colors={[Colors.primary, Colors.secondary]}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 0 }}
            style={styles.gradient}>
            {loading ? (
              <ActivityIndicator color={Colors.white} />
            ) : (
              <Text style={styles.buttonText}>Sign In</Text>
            )}
          </LinearGradient>
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
};

export default LoginScreen;
--- src/screens/Login/styles.tsx ---
import {StyleSheet} from 'react-native';
import {
  Colors,
  Fonts,
  Responsive,
  BorderRadius,
  Spacing,
} from '../../globalStyles';

const {wp, hp, fontSize} = Responsive;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.background,
  },
  header: {
    alignItems: 'center',
    marginTop: hp(5),
    marginBottom: hp(4),
  },
  logo: {
    width: wp(60),
    height: wp(24),
    resizeMode: 'cover',
    marginBottom: Spacing.m,
  },
  title: {
    fontSize: fontSize.xxl * 1.2,
    color: Colors.text,
    fontFamily: Fonts.PFbold,
    marginBottom: Spacing.s,
    letterSpacing: 1,
  },
  subtitle: {
    fontSize: fontSize.lg,
    color: Colors.textLight,
    fontFamily: Fonts.PFregular,
    opacity: 0.8,
  },
  card: {
    backgroundColor: Colors.white,
    borderRadius: BorderRadius.xl,
    padding: Spacing.xl,
    // marginHorizontal: Spacing.l,
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.background,
    borderRadius: BorderRadius.lg,
    paddingHorizontal: Spacing.m,
    marginBottom: Spacing.m,
    height: hp(7),
    borderWidth: 1,
    borderColor: Colors.lightGray,
  },
  icon: {
    width: wp(5),
    height: wp(5),
    tintColor: Colors.textLight,
    marginRight: Spacing.s,
  },
  authError: {
    color: Colors.error,
    marginTop: Spacing.s,
    marginBottom: Spacing.xs,
    textAlign: 'center',
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  input: {
    flex: 1,
    fontSize: fontSize.md,
    color: Colors.text,
    fontFamily: Fonts.PFmedium,
    paddingVertical: Spacing.s,
  },
  forgotPasswordContainer: {
    alignItems: 'flex-end',
    marginBottom: Spacing.l,
  },
  forgotPasswordText: {
    color: Colors.primary,
    fontSize: fontSize.md,
    fontFamily: Fonts.PFmedium,
  },
  button: {
    borderRadius: BorderRadius.lg,
    height: hp(7),
    overflow: 'hidden',
  },
  gradient: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  buttonText: {
    color: Colors.white,
    fontSize: fontSize.lg,
    fontFamily: Fonts.PFbold,
  },
  buttonDisabled: {
    opacity: 0.6,
  },
  floatingLabel: {
    position: 'absolute',
    left: Spacing.m,
    fontFamily: Fonts.PFmedium,
    color: Colors.textLight,
  },
});

export default styles;
--- src/screens/Password/styles.tsx ---
import { StyleSheet } from 'react-native';
import { Fonts } from '../../globalStyles';

export const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: '#FDFAF6',
    },
    keyboardAvoidingView: {
      flex: 1,
    },
    innerContainer: {
      flex: 1,
      justifyContent: 'center',
      paddingHorizontal: 24,
    },
    title: {
      fontSize: 40,
      color: '#000',
      fontFamily:Fonts.PFbold,
      marginBottom: 8,
      textAlign:'center',
    },
    subtitle: {
      textAlign: 'center',
      marginBottom: 40,
      fontSize: 20,
      color: '#95A1C3',
      fontFamily:Fonts.PFregular,
    },
    card: {
      backgroundColor: '#FFFFFF',
      borderRadius: 16,
      padding: 24,
    },
    inputContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: '#F5F8FF',
      borderRadius: 12,
      paddingHorizontal: 16,
      marginBottom: 16,
      height: 56,
    },
    floatingLabel: {
      position: 'absolute',
      left: 16,
      fontFamily: Fonts.PFmedium,
      fontSize:24,
    },
    icon: {
      width: 20,
      height: 20,
      tintColor: '#95A1C3',
      marginRight: 12,
    },
    input: {
      flex: 1,
      fontSize: 20,
      color: '#333',
      fontFamily: Fonts.PFmedium,
    },
    updateButton: {
      borderRadius: 12,
      overflow: 'hidden',
      marginTop: 20,
    },
    gradient: {
      padding: 16,
      alignItems: 'center',
    },
    updateButtonText: {
      color: '#FFFFFF',
      fontSize: 32,
      fontFamily: Fonts.PFbold,
    },
    skipButton: {
      marginTop: 20,
      alignItems: 'center',
    },
    skipButtonText: {
      fontSize: 20,
      color: '#5271FF',
      fontWeight: '600',
      textDecorationLine: 'underline',
      fontFamily: Fonts.PFmedium,
    },
  });
--- src/screens/Password/UpdatePassword.tsx ---
import React, { useRef, useState } from 'react';
import { View, Text, TextInput, TouchableOpacity, SafeAreaView, KeyboardAvoidingView, Platform, Keyboard, Alert, TouchableWithoutFeedback, Animated, Pressable, Image } from 'react-native';
import LinearGradient from 'react-native-linear-gradient';
import { styles } from './styles';
import { account } from '../../lib/appwrite';
import { useAuth } from '../../context/AuthContext';

const UpdatePasswordScreen = ({ navigation }: any) => {
  const [newPassword, setNewPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const floatingLabelAnimNewPassword = useRef(new Animated.Value(0)).current;
  const floatingLabelAnimConfirmPassword = useRef(new Animated.Value(0)).current;
    const [showPassword, setShowPassword] = useState(false);

    const { checkLoggedIn } = useAuth();
  const animateLabel = (animValue: Animated.Value, isActive: boolean) => {
      Animated.timing(animValue, {
        toValue: isActive ? 1 : 0,
        duration: 200,
        useNativeDriver: false,
      }).start();
    };

    const floatingLabelStyle = (animValue: Animated.Value) => ({
      top: animValue.interpolate({
        inputRange: [0, 1],
        outputRange: [20, 5],
      }),
      fontSize: animValue.interpolate({
        inputRange: [0, 1],
        outputRange: [16, 12],
      }),
      color: animValue.interpolate({
        inputRange: [0, 1],
        outputRange: ['#95A1C3', '#5271FF'],
      }),
    });

  const handleUpdatePassword = async () => {
    if (!newPassword || !confirmPassword) {
      Alert.alert('Error', 'Please enter both passwords.');
      return;
    }

    if (newPassword === confirmPassword) {
      try {
        await account.updatePassword(newPassword);
        await account.updatePrefs({ passwordUpdated: true });
        Alert.alert('Success', 'Password updated successfully!');
        navigation.navigate('HomeScreen');
      } catch (error: any) {
        Alert.alert('Error', error?.message || 'Failed to update password.');
      }
    } else {
      Alert.alert('Error', 'Passwords do not match.');
    }
  };

  const handleSkip = async () => {
    try {
      await account.updatePrefs({ passwordUpdated: 'true' });
      await checkLoggedIn(); // triggers Router rerender
    } catch (error: any) {
      Alert.alert('Error', error?.message || 'Failed to skip.');
    }
  };

  return (
    <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
      <SafeAreaView style={styles.container}>
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={styles.keyboardAvoidingView}
        >
          <View style={styles.innerContainer}>
            <Text style={styles.title}>Update Password</Text>
            <Text style={styles.subtitle}>Secure your account with a new password</Text>

            <View style={styles.card}>
              <View style={styles.inputContainer}>
              <Animated.Text style={[styles.floatingLabel, floatingLabelStyle(floatingLabelAnimNewPassword)]}>
                New Password
              </Animated.Text>
              <TextInput
                style={styles.input}
                // placeholder="New Password"
                placeholderTextColor="#95A1C3"
                secureTextEntry={!showPassword}
                value={newPassword}
                onChangeText={setNewPassword}
                onFocus={() => animateLabel(floatingLabelAnimNewPassword, true)}
                onBlur={() => newPassword.length === 0 && animateLabel(floatingLabelAnimNewPassword, false)}
              />
            </View>

              <View style={styles.inputContainer}>
              <Animated.Text style={[styles.floatingLabel, floatingLabelStyle(floatingLabelAnimConfirmPassword)]}>
  Confirm New Password
</Animated.Text>
<TextInput
  style={styles.input}
  // placeholder="Confirm New Password"
  placeholderTextColor="#95A1C3"
  secureTextEntry={!showPassword}
  value={confirmPassword}
  onChangeText={setConfirmPassword}
  onFocus={() => animateLabel(floatingLabelAnimConfirmPassword, true)}
  onBlur={() => confirmPassword.length === 0 && animateLabel(floatingLabelAnimConfirmPassword, false)}
/>

                <Pressable onPress={() => setShowPassword(!showPassword)}>
                            <Image
                              source={showPassword ? require('../../assets/icons/eye.png') : require('../../assets/icons/eyeoff.png')}
                              style={[styles.icon]}
                            />
                          </Pressable>
              </View>

              <TouchableOpacity style={styles.updateButton} onPress={handleUpdatePassword}>
                <LinearGradient colors={['#5271FF', '#3B4BFF']} style={styles.gradient}>
                  <Text style={styles.updateButtonText}>Update Password</Text>
                </LinearGradient>
              </TouchableOpacity>

              <TouchableOpacity style={styles.skipButton} onPress={handleSkip}>
                <Text style={styles.skipButtonText}>Skip for now</Text>
              </TouchableOpacity>
            </View>
          </View>
        </KeyboardAvoidingView>
      </SafeAreaView>
    </TouchableWithoutFeedback>
  );
};



export default UpdatePasswordScreen;
--- src/screens/Splash/SplashScreen.tsx ---
import React, { useEffect, useRef } from 'react';
import { Animated, Easing, Text } from 'react-native';
import LinearGradient from 'react-native-linear-gradient';
import { Colors } from '../../globalStyles';
import { styles } from './styles';

const SplashScreen = () => {
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const scaleAnim = useRef(new Animated.Value(0.8)).current;

  useEffect(() => {
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 1000,
        easing: Easing.inOut(Easing.ease),
        useNativeDriver: true,
      }),
      Animated.spring(scaleAnim, {
        toValue: 1,
        tension: 10,
        friction: 3,
        useNativeDriver: true,
      }),
    ]).start();
  }, [fadeAnim, scaleAnim]);

  return (
    <LinearGradient
      colors={[Colors.background, Colors.white]}
      start={{ x: 0, y: 0 }}
      end={{ x: 1, y: 1 }}
      style={styles.container}
    >
      <Animated.View
        style={[
          styles.logoContainer,
          {
            opacity: fadeAnim,
            transform: [{ scale: scaleAnim }],
          },
        ]}
      >
        <Animated.Image
          source={require('../../assets/images/logo.png')}
          style={styles.image}
        />
        <Text style={styles.appName}>Attender</Text>
        <Text style={styles.tagline}>The Attendance App</Text>
      </Animated.View>
    </LinearGradient>
  );
};

export default SplashScreen;
--- src/screens/Splash/styles.tsx ---
import {StyleSheet} from 'react-native';
import {Colors, Fonts, Responsive, Spacing} from '../../globalStyles';

const {wp, fontSize} = Responsive;

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  logoContainer: {
    alignItems: 'center',
    transform: [{scale: 1.1}],
  },
  image: {
    width: wp(60),
    height: wp(24),
    resizeMode: 'cover',
    marginBottom: Spacing.m,
  },
  appName: {
    fontSize: fontSize.xxl * 1.5,
    color: Colors.text,
    fontFamily: Fonts.PFbold,
    marginBottom: Spacing.s,
    textAlign: 'center',
    letterSpacing: 1,
  },
  tagline: {
    fontSize: fontSize.lg,
    color: Colors.textLight,
    fontFamily: Fonts.PFmedium,
    textAlign: 'center',
    opacity: 0.8,
  },
});
--- src/screens/student/Home/HomeScreen.tsx ---
import React from 'react';
import { View, Text, TouchableOpacity, Alert, Image, Linking, Platform } from 'react-native';
import { useCameraPermission } from 'react-native-vision-camera';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import CalendarComponent from '../../../components/Calendar/CalendarComponent';
import LinearGradient from 'react-native-linear-gradient';
import { Colors } from '../../../globalStyles';
import { styles } from './styles';
import { useAuth } from '../../../context/AuthContext';
import { check, request, PERMISSIONS, RESULTS, Permission } from 'react-native-permissions';
import Geolocation from '@react-native-community/geolocation';

const HomeScreen = ({ navigation }: any) => {
  const { hasPermission: hasCameraPermission, requestPermission: requestCameraPermission } = useCameraPermission();
  const insets = useSafeAreaInsets();
  const { user, attendanceLogs } = useAuth();

  // Process attendance logs into the format required by CalendarComponent
  const dailyAttendanceData = attendanceLogs?.reduce<Record<string, string>>(
    (acc, log) => {
      const date = log.Marked_at.split('T')[0]; // Extract date part (e.g., "2025-05-10")
      acc[date] = log.Status; // "Present" or "Absent"
      return acc;
    },
    {}
  ) || {};

  // Calculate attendance stats
  const totalDays = Object.keys(dailyAttendanceData).length;
  const presentDays = Object.values(dailyAttendanceData).filter(status => status === 'Present').length;
  const absentDays = totalDays - presentDays;
  const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;

  const requestLocationPermission = async () => {
    try {
      const permission = Platform.select({
        android: PERMISSIONS.ANDROID.ACCESS_FINE_LOCATION,
        ios: PERMISSIONS.IOS.LOCATION_WHEN_IN_USE,
      });

      const result = await check(permission as Permission);
      if (result === RESULTS.GRANTED) {
        return true;
      }

      const requestResult = await request(permission as Permission);
      if (requestResult === RESULTS.GRANTED) {
        return true;
      } else {
        Alert.alert(
          'Location Permission Denied',
          'We need location access to verify your location for attendance. Please enable it in your device settings.',
          [
            { text: 'Cancel', style: 'cancel' },
            { text: 'Open Settings', onPress: () => Linking.openSettings() },
          ]
        );
        return false;
      }
    } catch (error) {
      console.warn('❌ Location Permission Error:', error);
      Alert.alert('Error', 'Unable to request location permission. Please try again.');
      return false;
    }
  };

  const checkLocationServicesEnabled = async () => {
    return new Promise<boolean>((resolve) => {
      const timeout = setTimeout(() => {
        resolve(false);
      }, 5000);

      Geolocation.getCurrentPosition(
        () => {
          clearTimeout(timeout);
          resolve(true);
        },
        (error) => {
          clearTimeout(timeout);
          if (error.code === 2) {
            resolve(false);
          } else {
            resolve(true);
          }
        },
        { enableHighAccuracy: false, timeout: 5000, maximumAge: 10000 }
      );
    });
  };

  const handleScanPress = async () => {
    let cameraPermissionGranted = hasCameraPermission;
    if (!hasCameraPermission) {
      cameraPermissionGranted = await requestCameraPermission();
      if (!cameraPermissionGranted) {
        Alert.alert(
          'Camera Access Required',
          'We need camera access to scan QR codes for attendance. Please enable it in your device settings.',
          [
            { text: 'Cancel', style: 'cancel' },
            { text: 'Open Settings', onPress: () => Linking.openSettings() },
          ]
        );
        return;
      }
    }

    const locationPermissionGranted = await requestLocationPermission();
    if (!locationPermissionGranted) {
      return;
    }

    const locationServicesEnabled = await checkLocationServicesEnabled();
    if (!locationServicesEnabled) {
      Alert.alert(
        'Location Services Disabled',
        'Please enable location services to proceed with attendance marking.',
        [
          { text: 'Cancel', style: 'cancel' },
          { text: 'Open Settings', onPress: () => Linking.openSettings() },
        ]
      );
      return;
    }

    navigation.navigate('QrScreen');
  };

  return (
    <View style={[styles.container, { paddingTop: insets.top }]}>
      <View style={styles.header}>
        <View>
          <Text style={styles.greeting}>Welcome,</Text>
          <Text style={styles.name}>{user?.name ?? 'Student'}</Text>
        </View>
        <TouchableOpacity onPress={() => navigation.navigate('ProfileScreen')} style={styles.avatarContainer}>
          <Image source={require('../../../assets/images/avatar.png')} style={styles.avatar} />
        </TouchableOpacity>
      </View>

      <View style={styles.scrollContent}>
        <View style={styles.statsContainer}>
          <View style={styles.statCard}>
            <Text style={styles.statValue}>{attendancePercentage}%</Text>
            <Text style={styles.statLabel}>Attendance</Text>
          </View>
          <View style={styles.statCard}>
            <Text style={styles.statValue}>{presentDays}</Text>
            <Text style={styles.statLabel}>Present</Text>
          </View>
          <View style={styles.statCard}>
            <Text style={styles.statValue}>{absentDays}</Text>
            <Text style={styles.statLabel}>Absences</Text>
          </View>
        </View>

        <CalendarComponent attendanceData={dailyAttendanceData} />
      </View>

      <TouchableOpacity style={styles.scanButton} onPress={handleScanPress}>
        <LinearGradient
          colors={[Colors.primary, Colors.secondary]}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
          style={styles.gradient}
        >
          <Image source={require('../../../assets/icons/qr.png')} style={styles.scanIcon} />
        </LinearGradient>
      </TouchableOpacity>
    </View>
  );
};

export default HomeScreen;
--- src/screens/student/Home/styles.tsx ---
import { StyleSheet } from 'react-native';
import { Colors, Fonts, Responsive, BorderRadius, Spacing } from '../../../globalStyles';

const { wp, hp, fontSize } = Responsive;

export const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: Colors.background,
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: Spacing.l,
      paddingVertical: Spacing.m,
    },
    greeting: {
      fontSize: fontSize.xl,
      color: Colors.text,
      fontFamily: Fonts.PFmedium,
    },
    name: {
      fontSize: fontSize.xxl,
      color: Colors.text,
      fontFamily: Fonts.PFblack,
    },
    avatarContainer: {
      width: wp(12),
      height: wp(12),
      borderRadius: BorderRadius.round,
      backgroundColor: Colors.lightGray,
      justifyContent: 'center',
      alignItems: 'center',
      overflow: 'hidden',
    },
    avatar: {
      width: wp(12),
      height: wp(12),
    },
    scrollContent: {
      paddingHorizontal: Spacing.l,
      paddingBottom: Spacing.xl,
    },
    statsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginBottom: Spacing.l,
    },
    statCard: {
      flex: 1,
      backgroundColor: Colors.background,
      padding: Spacing.m,
      marginHorizontal: Spacing.xs,
      alignItems: 'center',
      borderWidth: 0.8,
      borderColor: Colors.gray,
      borderRadius: BorderRadius.lg,
    },
    statValue: {
      fontSize: fontSize.xxl,
      color: Colors.text,
      marginBottom: Spacing.xs,
      fontFamily: Fonts.PFbold,
    },
    statLabel: {
      fontSize: fontSize.lg,
      color: Colors.textLight,
      fontFamily: Fonts.PFmedium,
      textAlign: 'center',
    },
    scanButton: {
      position: 'absolute',
      bottom: Spacing.l,
      alignSelf: 'center',
      width: wp(18),
      height: wp(18),
      borderRadius: BorderRadius.round,
      justifyContent: 'center',
      alignItems: 'center',
      flexDirection: 'row',
      gap: Spacing.s,
    },
    gradient: {
      flex: 1,
      width: '100%',
      height: '100%',
      borderRadius: BorderRadius.round,
      justifyContent: 'center',
      alignItems: 'center',
    },
    scanIcon: {
      width: wp(8),
      height: wp(8),
      tintColor: Colors.white,
    },
    scanButtonText: {
      fontSize: 32,
      color: '#FFFFFF',
      fontFamily: Fonts.PFblack,
    },
  });
--- src/screens/student/Profile/ProfileScreen.tsx ---
import React, {useEffect, useState} from 'react';
import {
  View,
  Text,
  Image,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
} from 'react-native';
import {useSafeAreaInsets} from 'react-native-safe-area-context';
import LinearGradient from 'react-native-linear-gradient';
import {styles} from './styles';
import {useAuth} from '../../../context/AuthContext';
import {databases} from '../../../lib/appwrite';
import {Colors} from '../../../globalStyles';

// interface Course {
//   Programme: string;
//   Duration: number;
// }

interface StudentData {
  Name?: string;
  ABC_ID?: string;
  Course?: string;
  Batch?: string;
  Year?: string;
  Semester?: string;
  [key: string]: any;
}

const ProfileScreen = () => {
  const insets = useSafeAreaInsets();
  const [studentData, setStudentData] = useState<StudentData | null>(null);
  const {user: authUser, logout} = useAuth();

  const handleLogout = () => {
    Alert.alert('Logout', 'Are you sure you want to logout?', [
      {text: 'Cancel', style: 'cancel'},
      {text: 'Logout', onPress: logout, style: 'destructive'},
    ]);
  };
  console.log('Logged in user ID:', authUser?.$id);

  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchStudentData = async () => {
      try {
        const response = await databases.listDocuments(
          '6819e71f002774754561',
          '6819e983001dc900e9f9',
        );
        console.log('Response in Profile', response);

        if (response.total > 0) {
          setStudentData(response.documents[0]);
        } else {
          console.warn('No matching student found for Auth_ID:', authUser?.$id);
        }
      } catch (err) {
        console.error('Failed to fetch student profile:', err);
        Alert.alert('Error', 'Failed to load profile data. Please try again.');
      } finally {
        setLoading(false);
      }
    };

    if (authUser?.$id) {
      fetchStudentData();
    }
  }, [authUser]);

  if (loading) {
    return (
      <View style={[styles.container, styles.loadContainer]}>
        <ActivityIndicator size="large" color={Colors.primary} />
      </View>
    );
  }

  if (!studentData) {
    return (
      <View style={[styles.container, styles.loadContainer]}>
        <Text style={styles.headerTitle}>No student data found.</Text>
      </View>
    );
  }

  return (
    <View style={[styles.container, {paddingTop: insets.top}]}>
      <ScrollView contentContainerStyle={styles.scrollContent}>
        <View style={styles.profileSection}>
          <Image
            source={require('../../../assets/images/avatar.png')}
            style={styles.avatar}
          />
          <Text style={styles.userName}>{studentData.Name || 'N/A'}</Text>
          <Text style={styles.userId}>ID: {studentData.ABC_ID || 'N/A'}</Text>
        </View>

        <View style={styles.infoSection}>
          <Text style={styles.sectionTitle}>Personal Information</Text>
          <View style={styles.infoCard}>
            <View style={styles.infoItem}>
              <Text style={styles.infoLabel}>Email</Text>
              <Text style={styles.infoValue}>{authUser?.email}</Text>
            </View>
            <View style={styles.divider} />
            <View style={styles.infoItem}>
              <Text style={styles.infoLabel}>Phone Number</Text>
              <Text style={styles.infoValue}>{authUser?.phone}</Text>
            </View>
            <View style={styles.divider} />
            <View style={styles.infoItem}>
              <Text style={styles.infoLabel}>Course</Text>
              <Text style={styles.infoValue}>
                {studentData.Course
                  ? `${studentData.Course.Programme} (${studentData.Course.Duration} months)`
                  : 'N/A'}
              </Text>
            </View>
            <View style={styles.divider} />
            <View style={styles.infoItem}>
              <Text style={styles.infoLabel}>Batch</Text>
              <Text style={styles.infoValue}>{studentData.Batch}</Text>
            </View>
            <View style={styles.divider} />
            <View style={styles.infoItem}>
              <Text style={styles.infoLabel}>Year</Text>
              <Text style={styles.infoValue}>{studentData.Year} Year</Text>
            </View>
            <View style={styles.divider} />
            <View style={styles.infoItem}>
              <Text style={styles.infoLabel}>Current Semester</Text>
              <Text style={styles.infoValue}>{studentData.Semester}</Text>
            </View>
          </View>
        </View>

        <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
          <LinearGradient
            colors={[Colors.error, Colors.errorLight]}
            style={styles.gradient}>
            <Text style={styles.logoutText}>Log Out</Text>
          </LinearGradient>
        </TouchableOpacity>
      </ScrollView>
    </View>
  );
};

export default ProfileScreen;
--- src/screens/student/Profile/styles.tsx ---
import { StyleSheet } from 'react-native';
import { Fonts } from '../../../globalStyles';

export const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: '#FDFAF6',
    },
    loadContainer:{
      justifyContent: 'center',
      alignItems: 'center',
    },
    header: {
      paddingVertical: 16,
      paddingHorizontal: 20,
      alignItems: 'center',
    },
    headerTitle: {
      fontSize: 24,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    scrollContent: {
      paddingBottom: 30,
      marginTop:16,
    },
    profileSection: {
      alignItems: 'center',
      paddingVertical: 24,
    },
    avatar: {
      width: 100,
      height: 100,
      borderRadius: 50,
      marginBottom: 16,
    },
    userName: {
      fontSize: 32,
      color: '#333',
      marginBottom: 4,
      fontFamily: Fonts.PFbold,
    },
    userId: {
      fontSize: 24,
      color: '#95A1C3',
      fontFamily: Fonts.PFmedium,
    },
    infoSection: {
      paddingHorizontal: 20,
      marginBottom: 24,
    },
    sectionTitle: {
      fontSize: 24,
      color: '#333',
      marginBottom: 16,
      fontFamily: Fonts.PFbold,
    },
    infoCard: {
      backgroundColor: '#FFFFFF',
      borderRadius: 16,
      padding: 16,
    },
    infoItem: {
      paddingVertical: 12,
    },
    infoLabel: {
      fontSize: 20,
      color: '#95A1C3',
      marginBottom: 4,
      fontFamily: Fonts.PFmedium,
    },
    infoValue: {
      fontSize: 20,
      color: '#333',
      fontFamily: Fonts.PFbold,
    },
    divider: {
      height: 1,
      backgroundColor: '#E2E8F0',
    },
    logoutButton: {
      borderRadius: 12,
      overflow: 'hidden',
      marginHorizontal: 20,
      marginBottom: 16,
    },
    gradient: {
      padding: 16,
      alignItems: 'center',
    },
    logoutText: {
      color: '#FFFFFF',
      fontSize: 32,
      fontFamily: Fonts.PFbold,
    },
  });
--- src/screens/student/Qr/QrScreen.tsx ---
import React, { useEffect, useState, useCallback } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  Image,
  Alert,
  Linking,
  ActivityIndicator,
} from 'react-native';
import {
  Camera,
  useCameraDevice,
  useCodeScanner,
} from 'react-native-vision-camera';
import { useCameraPermission } from 'react-native-vision-camera';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { styles } from './styles';
import { useFocusEffect } from '@react-navigation/native';
import { ID, Query } from 'appwrite';
import { databases } from '../../../lib/appwrite';
import { useData } from '../../../context/DataContext';
import Geolocation from '@react-native-community/geolocation';
import { Colors } from '../../../globalStyles';

const QrScreen = ({ navigation }: any) => {
  const device = useCameraDevice('back');
  const { hasPermission } = useCameraPermission();
  const [scannedData, setScannedData] = useState<string | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const [torchActive, setTorchActive] = useState(false);
  const [latitude, setLatitude] = useState<number | null>(null);
  const [longitude, setLongitude] = useState<number | null>(null);
  const [locationFetched, setLocationFetched] = useState(false);
  const [isCameraActive, setIsCameraActive] = useState(true);
  const insets = useSafeAreaInsets();
  const { studentData, fetchStudentData } = useData();

  const resetCamera = useCallback(() => {
    setScannedData(null);
    setIsProcessing(false);
    setLocationFetched(false);
    setIsCameraActive(true);
  }, []);

  useFocusEffect(
    useCallback(() => {
      resetCamera();
      return () => {
        // Cleanup when screen loses focus
        setIsCameraActive(false);
      };
    }, [resetCamera])
  );

  const getCurrentPosition = useCallback(async (retryCount = 0, maxRetries = 2): Promise<void> => {
    Geolocation.getCurrentPosition(
      (position) => {
        setLatitude(position.coords.latitude);
        setLongitude(position.coords.longitude);
        setLocationFetched(true);
        console.log('✅ Location fetched:', position.coords);
      },
      (error: any) => {
        if (error.code === 2) {
          Alert.alert(
            'Location Services Disabled',
            'Please enable location services to proceed with attendance marking.',
            [
              { text: 'Cancel', style: 'cancel', onPress: () => navigation.goBack() },
              { text: 'Open Settings', onPress: () => Linking.openSettings() },
            ]
          );
          setLatitude(null);
          setLongitude(null);
          setLocationFetched(false);
        } else if (error.code === 3 && retryCount < maxRetries) {
          console.warn(`⏳ Location fetch timed out, retrying (${retryCount + 1}/${maxRetries})...`);
          Geolocation.getCurrentPosition(
            (position) => {
              setLatitude(position.coords.latitude);
              setLongitude(position.coords.longitude);
              setLocationFetched(true);
              console.log('✅ Location fetched on retry:', position.coords);
            },
            (retryError) => {
              if (retryCount + 1 < maxRetries) {
                getCurrentPosition(retryCount + 1, maxRetries);
              } else {
                Alert.alert('Error', 'Failed to fetch location after retries. Please try again.');
                setLatitude(null);
                setLongitude(null);
                setLocationFetched(false);
              }
            },
            { enableHighAccuracy: false, timeout: 10000, maximumAge: 10000 }
          );
        } else {
          Alert.alert('Error', 'Failed to fetch location. Please try again.');
          setLatitude(null);
          setLongitude(null);
          setLocationFetched(false);
        }
      },
      { enableHighAccuracy: true, timeout: 15000, maximumAge: 10000 }
    );
  }, [navigation]);

  useEffect(() => {
    if (!studentData) {
      fetchStudentData();
    }
    getCurrentPosition();
  }, [studentData, fetchStudentData, getCurrentPosition]);

  let scanTriggered = false;

  const handleScanError = useCallback((message: string) => {
    Alert.alert('Error', message, [
      {
        text: 'Try Again',
        onPress: resetCamera,
      },
      {
        text: 'Go Back',
        onPress: () => navigation.goBack(),
      },
    ]);
  }, [resetCamera, navigation]);

  const codeScanner = useCodeScanner({
    codeTypes: ['qr'],
    onCodeScanned: async (codes) => {
      if (
        codes.length > 0 &&
        codes[0].value &&
        !scannedData &&
        !isProcessing &&
        !scanTriggered
      ) {
        if (latitude === null || longitude === null) {
  handleScanError('Fetching your location. Please wait a moment.');
  return;
}

        scanTriggered = true;
        const qrString = codes[0].value;
        const scanTime = new Date().toLocaleDateString('sv-SE', {
          timeZone: 'Asia/Kolkata',
        });
        const timeStamp = new Date()
          .toLocaleString('sv-SE', { hour12: false, timeZone: 'Asia/Kolkata' })
          .replace(' ', 'T') + '+05:30';

        setScannedData(qrString);
        setIsProcessing(true);

        let qrData;
        try {
          qrData = JSON.parse(qrString);
        } catch (error) {
          handleScanError('Invalid QR code format.');
          return;
        }

        const { expiresAt, courseId, latitude: adminLatitude, longitude: adminLongitude } = qrData;


        {/*//if (!expiresAt || !courseId || adminLatitude == null || adminLongitude == null) {
  handleScanError('Invalid or incomplete QR code.');
  return;
}

const now = new Date();
const expiryDate = new Date(expiresAt);
if (isNaN(expiryDate.getTime()) || now > expiryDate) {
  handleScanError('This QR code has expired.');
  return;
}*/}
        // if (!expiresAt || !courseId) {
        //   handleScanError('Invalid QR code data.');
        //   return;
        // }
                if (!expiresAt || !courseId || adminLatitude == null || adminLongitude == null) {
  handleScanError('Invalid or incomplete QR code.');
  return;
}

        if (!studentData?.$id) {
          handleScanError('Student data not loaded');
          return;
        }

        const studentCourseId = studentData.Course.$id;
        if (studentCourseId !== courseId) {
          handleScanError('You are not enrolled in this course.');
          return;
        }

       const now = new Date();
const expiryDate = new Date(expiresAt);
if (isNaN(expiryDate.getTime()) || now > expiryDate) {
  handleScanError('This QR code has expired.');
  return;
}

console.log('Now', now);
console.log('expiryDate', expiryDate);
console.log('expiresAt', expiresAt);
console.log('expiryDate.getTime()', expiryDate.getTime());


        const existingAttendance = await databases.listDocuments(
          '6819e71f002774754561',
          '6819e8e100130bc54117',
          [
            Query.equal('Student_Id', studentData?.$id),
            Query.equal('Course_Id', courseId),
            Query.equal('Status', 'Present'),
            Query.greaterThanEqual('Marked_at', now.toISOString().split('T')[0] + 'T00:00:00Z'),
            Query.lessThanEqual('Marked_at', now.toISOString().split('T')[0] + 'T23:59:59Z'),
          ]
        );

        if (existingAttendance.total > 0) {
          Alert.alert('Already Marked', 'You have already marked attendance for this course today.', [
            {
              text: 'OK',
              onPress: () => {
                setIsProcessing(false);
                navigation.goBack();
              },
            },
          ]);
          return;
        }

        if (latitude !== null && longitude !== null && adminLatitude !== null && adminLongitude !== null) {
          const distance = calculateDistance(
            latitude,
            longitude,
            adminLatitude,
            adminLongitude
          );
          if (distance > 100) {
            handleScanError('You are not within 100 meters of the session location.');
            return;
          }
        } else {
          handleScanError('Location data is missing. Unable to verify proximity.');
          return;
        }

        try {
          await databases.createDocument(
            '6819e71f002774754561',
            '6819e8e100130bc54117',
            ID.unique(),
            {
              Student_Id: studentData.$id,
              Course_Id: courseId,
              Status: 'Present',
              Marked_at: timeStamp,
              Marked_By: studentData.Name, // or studentData.Email if more reliable
              Session_Id: ID.unique(), // if you're using session tracking
              Latitude: latitude,
              Longitude: longitude,
            }
          );


          Alert.alert('Success', 'Attendance marked successfully!', [
            {
              text: 'OK',
              onPress: () => {
                setIsProcessing(false);
                navigation.goBack();
              },
            },
          ]);
        } catch (error) {
          console.error('Error marking attendance:', error);
          handleScanError('Failed to mark attendance. Please try again.');
        }
      }
    },
  });

  const calculateDistance = (lat1: number, lon1: number, lat2: number, lon2: number) => {
    const R = 6371e3; // Earth's radius in meters
    const φ1 = (lat1 * Math.PI) / 180;
    const φ2 = (lat2 * Math.PI) / 180;
    const Δφ = ((lat2 - lat1) * Math.PI) / 180;
    const Δλ = ((lon2 - lon1) * Math.PI) / 180;

    const a =
      Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c; // Distance in meters
  };

  if (!hasPermission) {
    return (
      <View style={[styles.permissionContainer, { paddingTop: insets.top }]}>
        <Image
          source={require('../../../assets/icons/camera.png')}
          style={styles.permissionIcon}
        />
        <Text style={styles.permissionTitle}>Camera Access Required</Text>
        <Text style={styles.permissionText}>
          We need camera access to scan QR codes for attendance marking.
          Please enable it in your device settings.
        </Text>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}>
          <Text style={styles.headerTitle}>Go Back</Text>
        </TouchableOpacity>
      </View>
    );
  }

  if (!device) {
    return (
      <View style={[styles.permissionContainer, { paddingTop: insets.top }]}>
        <Text style={styles.permissionTitle}>Camera Not Available</Text>
        <Text style={styles.permissionText}>
          Unable to access the camera. Please make sure your device has a working camera.
        </Text>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}>
          <Text style={styles.headerTitle}>Go Back</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <View style={[styles.container, { paddingTop: insets.top }]}>
      {isCameraActive && (
        <Camera
          style={styles.camera}
          device={device}
          isActive={isCameraActive}
          codeScanner={codeScanner}
          torch={torchActive ? 'on' : 'off'}
        />
      )}

      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}>
          <Image
            source={require('../../../assets/icons/back.png')}
            style={styles.backIcon}
          />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Scan QR Code</Text>
        <TouchableOpacity
          style={styles.torchButton}
          onPress={() => setTorchActive(!torchActive)}>
          <Image
            source={require('../../../assets/icons/flash.png')}
            style={[
              styles.torchIcon,
              { tintColor: torchActive ? Colors.primary : Colors.white },
            ]}
          />
        </TouchableOpacity>
      </View>

      <View style={styles.overlay}>
        <View style={styles.scanArea}>
          <View style={[styles.corner, styles.topLeftCorner]} />
          <View style={[styles.corner, styles.topRightCorner]} />
          <View style={[styles.corner, styles.bottomLeftCorner]} />
          <View style={[styles.corner, styles.bottomRightCorner]} />
        </View>
        <Text style={styles.instructionText}>
          Position the QR code within the frame to scan
        </Text>
      </View>

      {isProcessing && (
        <View style={styles.processingContainer}>
          <View style={styles.processingIndicator}>
            <ActivityIndicator color={Colors.white} size="large" />
            <Text style={styles.processingText}>Processing...</Text>
          </View>
        </View>
      )}
    </View>
  );
};

export default QrScreen;
--- src/screens/student/Qr/styles.tsx ---
import {StyleSheet} from 'react-native';
import { Fonts } from '../../../globalStyles';

export const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: '#000',
    },
    camera: {
      flex: 1,
    },
    header: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: 16,
      paddingHorizontal: 20,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      zIndex: 10,
    },
    backButton: {
      width: 40,
      height: 40,
      borderRadius: 20,
      backgroundColor: 'rgba(208, 208, 208, 0.5)',
      justifyContent: 'center',
      alignItems: 'center',
    },
    backIcon: {
      width: 20,
      height: 20,
      tintColor: '#FFFFFF',
    },
    headerTitle: {
      fontSize: 24,
      color: '#FFFFFF',
      fontFamily: Fonts.PFbold,
    },
    torchButton: {
      width: 40,
      height: 40,
      borderRadius: 20,
      backgroundColor: 'rgba(208, 208, 208, 0.5)',
      justifyContent: 'center',
      alignItems: 'center',
    },
    torchIcon: {
      width: 20,
      height: 20,
      tintColor: '#FFFFFF',
    },
    overlay: {
      ...StyleSheet.absoluteFillObject,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
    },
    scanArea: {
      width: 250,
      height: 250,
      borderRadius: 16,
      backgroundColor: 'transparent',
      overflow: 'hidden',
      justifyContent: 'center',
      alignItems: 'center',
    },
    corner: {
      position: 'absolute',
      width: 24,
      height: 24,
      borderColor: '#FFFFFF',
    },
    topLeftCorner: {
      top: 0,
      left: 0,
      borderTopWidth: 3,
      borderLeftWidth: 3,
      borderTopLeftRadius: 16,
    },
    topRightCorner: {
      top: 0,
      right: 0,
      borderTopWidth: 3,
      borderRightWidth: 3,
      borderTopRightRadius: 16,
    },
    bottomLeftCorner: {
      bottom: 0,
      left: 0,
      borderBottomWidth: 3,
      borderLeftWidth: 3,
      borderBottomLeftRadius: 16,
    },
    bottomRightCorner: {
      bottom: 0,
      right: 0,
      borderBottomWidth: 3,
      borderRightWidth: 3,
      borderBottomRightRadius: 16,
    },
    instructionText: {
      marginTop: 32,
      color: '#FFFFFF',
      fontSize: 20,
      textAlign: 'center',
      paddingHorizontal: 40,
      fontFamily: Fonts.PFregular,
    },
    processingContainer: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.7)',
      justifyContent: 'center',
      alignItems: 'center',
    },
    processingIndicator: {
      backgroundColor: '#5271FF',
      paddingVertical: 12,
      paddingHorizontal: 24,
      borderRadius: 12,
    },
    processingText: {
      color: '#FFFFFF',
      fontSize: 20,
      fontFamily: Fonts.PFregular,
    },
    permissionContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: '#F5F8FF',
      padding: 24,
    },
    permissionIcon: {
      width: 80,
      height: 80,
      tintColor: '#95A1C3',
      marginBottom: 24,
    },
    permissionTitle: {
      fontSize: 22,
      fontWeight: 'bold',
      color: '#333',
      marginBottom: 12,
      textAlign: 'center',
    },
    permissionText: {
      fontSize: 16,
      color: '#95A1C3',
      textAlign: 'center',
      marginBottom: 32,
    },
  });
